{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.22;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC-1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC-1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC-1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC-1967 compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC-1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {ERC721Utils} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC-721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721\n    struct ERC721Storage {\n        // Token name\n        string _name;\n\n        // Token symbol\n        string _symbol;\n\n        mapping(uint256 tokenId => address) _owners;\n\n        mapping(address owner => uint256) _balances;\n\n        mapping(uint256 tokenId => address) _tokenApprovals;\n\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC-721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if:\n     * - `spender` does not have approval from `owner` for `tokenId`.\n     * - `spender` does not have approval to manage all of `owner`'s assets.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n\n        $._owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC-721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        $._tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721Upgradeable} from \"../ERC721Upgradeable.sol\";\nimport {IERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the ERC that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: {ERC721} extensions that implement custom `balanceOf` logic, such as {ERC721Consecutive},\n * interfere with enumerability and should not be used together with {ERC721Enumerable}.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721Enumerable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721Enumerable\n    struct ERC721EnumerableStorage {\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721Enumerable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721EnumerableStorageLocation = 0x645e039705490088daad89bae25049a34f4a9072d398537b1ab2425f24cbed00;\n\n    function _getERC721EnumerableStorage() private pure returns (ERC721EnumerableStorage storage $) {\n        assembly {\n            $.slot := ERC721EnumerableStorageLocation\n        }\n    }\n\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return $._ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        return $._allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return $._allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_update}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        uint256 length = balanceOf(to) - 1;\n        $._ownedTokens[to][length] = tokenId;\n        $._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        $._allTokensIndex[tokenId] = $._allTokens.length;\n        $._allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = $._ownedTokensIndex[tokenId];\n\n        mapping(uint256 index => uint256) storage _ownedTokensByOwner = $._ownedTokens[from];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokensByOwner[lastTokenIndex];\n\n            _ownedTokensByOwner[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            $._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete $._ownedTokensIndex[tokenId];\n        delete _ownedTokensByOwner[lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        ERC721EnumerableStorage storage $ = _getERC721EnumerableStorage();\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = $._allTokens.length - 1;\n        uint256 tokenIndex = $._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = $._allTokens[lastTokenIndex];\n\n        $._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        $._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete $._allTokensIndex[tokenId];\n        $._allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.22;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Ownable} from \"../../access/Ownable.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev The `implementation` of the beacon is invalid.\n     */\n    error BeaconInvalidImplementation(address implementation);\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.\n     */\n    constructor(address implementation_, address initialOwner) Ownable(initialOwner) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert BeaconInvalidImplementation(newImplementation);\n        }\n        _implementation = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.22;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {IERC1967} from \"../../interfaces/IERC1967.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This library provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\n */\nlibrary ERC1967Utils {\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit IERC1967.Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the ERC-1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit IERC1967.BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/utils/ERC721Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../IERC721Receiver.sol\";\nimport {IERC721Errors} from \"../../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Library that provide common ERC-721 utility functions.\n *\n * See https://eips.ethereum.org/EIPS/eip-721[ERC-721].\n *\n * _Available since v5.1._\n */\nlibrary ERC721Utils {\n    /**\n     * @dev Performs an acceptance check for the provided `operator` by calling {IERC721-onERC721Received}\n     * on the `to` address. The `operator` is generally the address that initiated the token transfer (i.e. `msg.sender`).\n     *\n     * The acceptance call is not executed and treated as a no-op if the target address doesn't contain code (i.e. an EOA).\n     * Otherwise, the recipient must implement {IERC721Receiver-onERC721Received} and return the acceptance magic value to accept\n     * the transfer.\n     */\n    function checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    // Token rejected\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    // non-IERC721Receiver implementer\n                    revert IERC721Errors.ERC721InvalidReceiver(to);\n                } else {\n                    assembly (\"memory-safe\") {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guaratees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
    },
    "contracts/BBCardDealer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBCardUtils.sol\";\r\nimport \"./BBTypes.sol\";\r\n\r\n/**\r\n * @title BBCardDealer\r\n * @dev 牌局管理工具，负责发牌和记录已发的牌\r\n * @notice 进行了以下优化：\r\n *  - 改进随机性处理\r\n *  - 优化避免重复牌的算法\r\n *  - 明确使用标准52张扑克牌(无大小王)\r\n *  - 增加边界检查\r\n *  - 减少 gas 消耗\r\n *  - 添加事件通知\r\n *  - 完善 NatSpec 文档\r\n */\r\nlibrary BBCardDealer {\r\n    // 牌组常量\r\n    uint8 internal constant TOTAL_CARDS = 52; // 标准52张扑克牌(无大小王)\r\n\r\n    /**\r\n     * @dev 发牌管理器状态\r\n     */\r\n    struct DealerState {\r\n        mapping(uint8 => bool) usedCards; // 已使用的牌\r\n        uint256 lastSeed;      // 上次使用的随机种子\r\n    }\r\n\r\n    /**\r\n     * @dev 初始化发牌状态(使用默认的5张牌)\r\n     * @param self 发牌状态\r\n     * @param newSeed 初始随机种子\r\n     */\r\n    function initialize(DealerState storage self, uint256 newSeed) internal {\r\n        self.lastSeed = uint256(keccak256(abi.encodePacked(\r\n            self.lastSeed,\r\n            block.prevrandao,\r\n            block.timestamp,\r\n            newSeed\r\n        )));\r\n    }\r\n\r\n    /**\r\n     * @dev 重置发牌状态\r\n     * @param self 发牌状态\r\n     */\r\n    function reset(DealerState storage self) internal {\r\n        // Clear all used cards by iterating through 1 to TOTAL_CARDS\r\n        for (uint8 i = 1; i <= TOTAL_CARDS; i++) {\r\n            self.usedCards[i] = false;\r\n        }\r\n\r\n        // 重置随机种子\r\n        self.lastSeed = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev 使用改进的算法生成单张牌，确保不与玩家已有牌重复\r\n     * @param self 发牌状态\r\n     * @param player 玩家地址\r\n     * @return 新生成的牌 (1-52范围内)\r\n     */\r\n    function generateCard(\r\n        DealerState storage self, \r\n        address player,\r\n        uint8 count\r\n    ) internal returns (uint8) {        \r\n        // 生成1-52的牌 (标准52张扑克牌，无大小王)\r\n        uint8 newCard;\r\n        uint8 attempts = 0;\r\n        \r\n        // 使用映射快速检查是否重复，最多尝试25次\r\n        do {\r\n            uint256 hash = uint256(keccak256(abi.encodePacked(self.lastSeed, player, count, attempts)));\r\n            // 确保范围在1-52之间 (% TOTAL_CARDS + 1)\r\n            newCard = uint8((hash % TOTAL_CARDS) + 1);\r\n            attempts++;\r\n            \r\n            // 防止无限循环\r\n            require(attempts <= 25, \"Failed to generate unique card\");\r\n            \r\n        } while (self.usedCards[newCard]);\r\n        \r\n        // 记录该牌已被使用\r\n        self.usedCards[newCard] = true;\r\n\r\n        return newCard;\r\n    }\r\n\r\n    /**\r\n     * @dev 为玩家发指定数量的牌\r\n     * @param self 发牌状态\r\n     * @param player 玩家地址\r\n     * @param count 要发的牌数量\r\n     * @return 新发的牌\r\n     */\r\n    function dealCards(\r\n        DealerState storage self, \r\n        address player, \r\n        uint8 count\r\n    ) internal returns (uint8[] memory) {            \r\n        uint8[] memory newCards = new uint8[](count);\r\n\r\n        for (uint8 i = 0; i < count; i++) {\r\n            // 为每张牌使用不同的种子\r\n            newCards[i] = generateCard(self, player, count);\r\n        }\r\n\r\n        return newCards;\r\n    }\r\n\r\n    /**\r\n     * @dev 根据轮次为多个玩家发牌\r\n     * @param self 发牌状态\r\n     * @param round 当前轮次(1=第一轮发3张, 2=第二轮发1张, 3=第三轮发1张)\r\n     */\r\n    function dealCardsByRoundForPlayer(\r\n        DealerState storage self,\r\n        address player,\r\n        uint8 round\r\n    ) internal returns (uint8[] memory)  {\r\n        require(round >= 1 && round <= 3, \"Invalid round\");\r\n\r\n        // 根据轮次确定发牌数量\r\n        uint8 cardCount = round == 1 ? 3 : 1;\r\n\r\n        // 更新随机种子，加入轮次信息和区块信息增加随机性\r\n        self.lastSeed = uint256(keccak256(abi.encodePacked(\r\n            self.lastSeed, \r\n            player,\r\n            round, \r\n            block.timestamp, \r\n            block.difficulty\r\n        )));\r\n\r\n        return dealCards(self, player, cardCount);\r\n    }\r\n}\r\n"
    },
    "contracts/BBCardUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\n\r\n/**\r\n * @title CardUtils\r\n * @dev 牌型计算和比较的工具库\r\n */\r\nlibrary BBCardUtils {\r\n    /**\r\n     * @dev 合并两轮牌\r\n     */\r\n    function combineCards(uint8[3] memory firstCards, uint8[2] memory secondCards) internal pure returns (uint8[5] memory) {\r\n        uint8[5] memory allCards;\r\n\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            allCards[i] = firstCards[i];\r\n        }\r\n\r\n        for (uint8 i = 0; i < 2; i++) {\r\n            allCards[i + 3] = secondCards[i];\r\n        }\r\n\r\n        return allCards;\r\n    }\r\n\r\n    /**\r\n     * @dev 计算牌型\r\n     */\r\n    function calculateCardType(uint8[5] memory cards) internal pure returns (CardType) {\r\n        // 检查是否有无效牌（0表示无效牌）\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            if (cards[i] == 0) {\r\n                return CardType.NONE;\r\n            }\r\n        }\r\n        \r\n        // 转换牌面值（1-13）和花色（0-3）\r\n        uint8[5] memory values;\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            values[i] = ((cards[i] - 1) % 13) + 1;\r\n        }\r\n\r\n        // 检查特殊牌型\r\n        if (isFiveFlower(values)) {\r\n            return CardType.FIVE_FLOWERS;\r\n        }\r\n        \r\n        if (isFiveBomb(values)) {\r\n            return CardType.FIVE_BOMB;\r\n        }\r\n\r\n        if (isFiveSmall(values)) {\r\n            return CardType.FIVE_SMALL;\r\n        }\r\n\r\n        // 计算牛牛牌型\r\n        return calculateBullType(values);\r\n    }\r\n\r\n    /**\r\n     * @dev 检查是否是五花牛（5张牌都是JQK）\r\n     */\r\n    function isFiveFlower(uint8[5] memory values) internal pure returns (bool) {\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            if (values[i] < 11) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev 检查是否是炸弹牛（4张相同点数）\r\n     */\r\n    function isFiveBomb(uint8[5] memory values) internal pure returns (bool) {\r\n        // 统计每个点数出现的次数\r\n        uint8[14] memory counts;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            counts[values[i]]++;\r\n        }\r\n\r\n        // 检查是否有点数出现4次\r\n        for (uint8 i = 1; i <= 13; i++) {\r\n            if (counts[i] == 4) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev 检查是否是五小牛（5张牌点数和小于等于10）\r\n     */\r\n    function isFiveSmall(uint8[5] memory values) internal pure returns (bool) {\r\n        uint8 sum = 0;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            // J、Q、K的点数都按10计算\r\n            uint8 value = values[i] > 10 ? 10 : values[i];\r\n            sum += value;\r\n        }\r\n\r\n        return sum <= 10;\r\n    }\r\n\r\n    /**\r\n     * @dev 计算有牛牌型\r\n     */\r\n    function calculateBullType(uint8[5] memory values) internal pure returns (CardType) {\r\n        // 转换点数（J、Q、K都按10计算）\r\n        uint8[5] memory points;\r\n        uint8 sum = 0;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            points[i] = values[i] > 10 ? 10 : values[i];\r\n            sum += points[i];\r\n        }\r\n\r\n        // 尝试所有可能的3张牌组合，看是否能凑成10的倍数\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            for (uint8 j = i + 1; j < 4; j++) {\r\n                for (uint8 k = j + 1; k < 5; k++) {\r\n                    uint8 threeSum = points[i] + points[j] + points[k];\r\n\r\n                    if (threeSum % 10 == 0) {\r\n                        // 找到一个有效组合，计算剩余两张牌的点数和\r\n                        uint8 remainingSum = sum - threeSum;\r\n                        uint8 remainder = remainingSum % 10;\r\n\r\n                        if (remainder == 0) {\r\n                            return CardType.BULL_BULL;\r\n                        } else {\r\n                            // 返回对应的牛几，需要加1来对应正确的枚举值\r\n                            return CardType(remainder + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 没有找到有效组合，返回无牛\r\n        return CardType.NO_BULL;\r\n    }\r\n\r\n    /**\r\n     * @dev 比较两个牌型的大小\r\n     * @return 1 如果cardType1大于cardType2，0 如果相等，-1 如果cardType1小于cardType2\r\n     */\r\n    function compareCardType(CardType cardType1, CardType cardType2) internal pure returns (int8) {\r\n        if (uint8(cardType1) > uint8(cardType2)) {\r\n            return 1;\r\n        } else if (uint8(cardType1) < uint8(cardType2)) {\r\n            return -1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/BBGameMain.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./BBTypes.sol\";\r\nimport \"./BBRoomCardNFT.sol\";\r\nimport \"./BBRewardPool.sol\";\r\nimport \"./BBRoomLevelNFT.sol\";\r\nimport \"./BBStructs.sol\";\r\nimport \"./BBInterfaces.sol\";\r\n\r\n\r\n\r\n/**\r\n * @title BBGameMain\r\n * @dev 牛牛明牌游戏主合约，管理多个游戏桌\r\n */\r\ncontract BBGameMain is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    ReentrancyGuardUpgradeable,\r\n    PausableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n\r\n    // 游戏配置\r\n    uint256 public nextTableId;\r\n    uint8 public maxRoomCount;  //最大创建房间数\r\n    uint8 public maxPlayers;\r\n    uint256 public playerTimeout;  // 玩家超时时间\r\n    uint256 public tableInactiveTimeout;  // 游戏桌不活跃超时时间\r\n    uint8 public maxBankerFeePercent; // 庄家抽成最大百分比\r\n    uint8 public liquidatorFeePercent; // 清算人费用百分比\r\n\r\n\r\n    // 游戏桌地址列表\r\n    address[] public tableAddresses;\r\n    mapping(address => address) public gameTables;\r\n    // 用户创建的游戏桌映射\r\n    mapping(address => address[]) public userTables;\r\n    // 用户加入的游戏桌映射\r\n    mapping(address => address[]) public userJoinedTables;\r\n\r\n    // 记录每个用户创建的房间数量\r\n    mapping(address => uint256) public userCreatedRoomsCount;\r\n\r\n    address public rewardPoolAddress;    // 奖励池合约地址\r\n\r\n\r\n    // 房卡相关\r\n    address public roomCardAddress;  // 房卡NFT合约地址\r\n\r\n    // 房间等级相关\r\n    address public roomLevelAddress; // 房间等级合约地址\r\n\r\n    // 游戏桌工厂相关\r\n    address public gameTableFactoryAddress; // 游戏桌工厂合约地址\r\n\r\n\r\n    // 预留 50 个 slot 给将来新增变量用，防止存储冲突\r\n    uint256[50] private __gap;\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @dev 初始化函数，替代构造函数\r\n     */\r\n    function initialize(\r\n        uint8 _maxPlayers,\r\n        uint8 _maxRoomCount,\r\n        uint8 _maxBankerFeePercent,\r\n        uint8 _liquidatorFeePercent,\r\n        uint256 _playerTimeout,\r\n        uint256 _tableInactiveTimeout,\r\n        address _gameTableFactoryAddress\r\n    ) public initializer {\r\n        __Ownable_init(msg.sender);\r\n        __ReentrancyGuard_init();\r\n        __Pausable_init();\r\n        __UUPSUpgradeable_init();\r\n\r\n        nextTableId = 1;\r\n        maxPlayers = _maxPlayers;\r\n        maxRoomCount = _maxRoomCount;\r\n        maxBankerFeePercent = _maxBankerFeePercent;\r\n        liquidatorFeePercent = _liquidatorFeePercent;\r\n        playerTimeout = _playerTimeout;\r\n        tableInactiveTimeout = _tableInactiveTimeout;\r\n\r\n        // 初始化游戏桌工厂地址\r\n        if (_gameTableFactoryAddress != address(0)) {\r\n            gameTableFactoryAddress = _gameTableFactoryAddress;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev 创建新游戏桌，调用者成为庄家\r\n     * @param tableName 游戏桌名称\r\n     * @param betAmount 固定押注金额\r\n     * @param tableMaxPlayers 最大玩家数量\r\n     * @param bankerFeePercent 庄家抽成百分比\r\n     */\r\n    function createGameTable(\r\n        string memory tableName,\r\n        uint256 betAmount,\r\n        uint8 tableMaxPlayers,\r\n        uint8 bankerFeePercent,\r\n        uint8 firstRaise,\r\n        uint8 secondRaise\r\n    ) external payable nonReentrant {\r\n        require(!paused(), \"Contract paused\");\r\n        require(betAmount != 0, \"Bet amount too small\");\r\n        require(tableMaxPlayers > 1 && tableMaxPlayers <= maxPlayers, \"Invalid max players\");\r\n        require(bankerFeePercent <= maxBankerFeePercent, \"Invalid banker fee percent\");\r\n        require(bytes(tableName).length > 0 && bytes(tableName).length <= 20, \"Invalid table name\");\r\n        require(firstRaise >= 1 && firstRaise <= 4, \"Invalid first raise\");\r\n        require(secondRaise >= 1 && secondRaise <= 4, \"Invalid second raise\");\r\n\r\n        // 将玩家的房间数量加1\r\n        userCreatedRoomsCount[msg.sender]++;\r\n\r\n        uint256 createdRooms = getUserCreatedRoomsCount(msg.sender);\r\n        // 验证用户的房间等级和已创建的房间数量\r\n        if (createdRooms > maxRoomCount) {\r\n            require(roomLevelAddress != address(0), \"Invalid room level address\");\r\n\r\n            // 验证用户是否拥有房间等级\r\n            BBRoomLevelNFT roomLevel = BBRoomLevelNFT(payable(roomLevelAddress));\r\n            require(roomLevel.hasNft(msg.sender), \"Room level required\");\r\n\r\n            // 获取用户等等级NFT可创建的房间总数\r\n            uint256 maxRooms = roomLevel.getMaxRooms(msg.sender);\r\n\r\n            // 验证用户是否超过房间创建上限\r\n            if (createdRooms > maxRooms + maxRoomCount) {\r\n                // 如果超过上限，先将计数减回去，再抛出错误\r\n                userCreatedRoomsCount[msg.sender]--;\r\n                require(false, \"room level limit exceeded\");\r\n            }\r\n        }\r\n\r\n        // 检查游戏桌工厂地址是否设置\r\n        require(gameTableFactoryAddress != address(0), \"Invalid game table factory address\");\r\n\r\n\r\n        // 使用工厂合约创建游戏桌\r\n        IGameTableFactory factory = IGameTableFactory(gameTableFactoryAddress);\r\n        address tableAddr = factory.createGameTable(\r\n            nextTableId,\r\n            tableName,\r\n            msg.sender,\r\n            betAmount,\r\n            tableMaxPlayers,\r\n            address(this),\r\n            bankerFeePercent,\r\n            firstRaise,\r\n            secondRaise\r\n        );\r\n\r\n        nextTableId++;\r\n        \r\n\r\n        // 添加到活跃游戏列表\r\n        tableAddresses.push(tableAddr);\r\n        gameTables[tableAddr] = tableAddr;\r\n        // 添加到用户的游戏桌列表\r\n        userTables[msg.sender].push(tableAddr);\r\n\r\n        // 触发事件\r\n        emit GameTableCreated(tableAddr, msg.sender, betAmount, tableMaxPlayers, bankerFeePercent);\r\n    }\r\n\r\n    // 获取tableAddresses列表\r\n    function getTableAddresses() external view returns (address[] memory) {\r\n        return tableAddresses;\r\n    }\r\n\r\n    // 获取用户加入的游戏桌列表\r\n    function getUserJoinedTables(address userAddress) external view returns (address[] memory) {\r\n        return userJoinedTables[userAddress];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev 暂停合约（仅限合约拥有者）\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev 恢复合约（仅限合约拥有者）\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function getGameConfig() external view returns (GameConfig memory) {\r\n        return GameConfig({\r\n            maxRoomCount: maxRoomCount,\r\n            maxPlayers: maxPlayers,\r\n            maxBankerFeePercent: maxBankerFeePercent,\r\n            playerTimeout: playerTimeout,\r\n            tableInactiveTimeout: tableInactiveTimeout,\r\n            liquidatorFeePercent: liquidatorFeePercent,\r\n            gameMainAddress: address(this),\r\n            rewardPoolAddress: rewardPoolAddress,\r\n            roomCardAddress: roomCardAddress,\r\n            roomLevelAddress: roomLevelAddress,\r\n            gameTableFactoryAddress: gameTableFactoryAddress\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev 更新游戏配置（仅限合约拥有者）\r\n     */\r\n    function updateGameConfig(\r\n        uint8 _maxPlayers,\r\n        uint8 _maxBankerFeePercent,\r\n        uint256 _playerTimeout,\r\n        uint256 _tableInactiveTimeout,\r\n        uint8 _liquidatorFeePercent\r\n    ) external onlyOwner {\r\n        require(_maxPlayers > 1, \"Invalid max players\");\r\n        require(_maxBankerFeePercent != 0 && _maxBankerFeePercent < 100, \"Banker fee percent must be positive\");\r\n        require(_playerTimeout != 0, \"Player timeout must be positive\");\r\n        require(_tableInactiveTimeout != 0, \"Table inactive timeout must be positive\");\r\n        require(_liquidatorFeePercent != 0 && _liquidatorFeePercent < 100, \"Invalid liquidator fee percent\");\r\n\r\n        maxPlayers = _maxPlayers;\r\n        maxBankerFeePercent = _maxBankerFeePercent;\r\n        playerTimeout = _playerTimeout;\r\n        tableInactiveTimeout = _tableInactiveTimeout;\r\n        liquidatorFeePercent = _liquidatorFeePercent;\r\n    }\r\n\r\n    /**\r\n     * @dev 设置房卡合约地址\r\n     * @param _roomCardAddress 房卡合约地址\r\n     */\r\n    function setRoomCardAddress(address _roomCardAddress) external onlyOwner {\r\n        require(_roomCardAddress != address(0), \"Invalid room card contract\");\r\n        roomCardAddress = _roomCardAddress;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev 获取最新的游戏桌\r\n     * @param _count 要获取的游戏桌数量\r\n     * @return 最新的游戏桌数组\r\n     */\r\n    function getNewestGameTables(uint8 _count) external view returns(GameTableInfoShort[] memory) {\r\n        require(_count > 0, \"Count must be greater than 0\");\r\n        \r\n        uint256 tableCount = tableAddresses.length;\r\n        if (tableCount == 0) {\r\n            return new GameTableInfoShort[](0);\r\n        }\r\n        \r\n        // 如果请求的数量大于现有游戏桌数量，则使用现有数量\r\n        uint256 resultCount = _count;\r\n        if (tableCount < resultCount) {\r\n            resultCount = tableCount;\r\n        }\r\n        \r\n        GameTableInfoShort[] memory tables = new GameTableInfoShort[](resultCount);\r\n        \r\n        // 使用安全的索引计算方式\r\n        uint256 startIndex = tableCount > resultCount ? tableCount - resultCount : 0;\r\n        \r\n        for (uint256 i = 0; i < resultCount; i++) {\r\n            address tableAddr = tableAddresses[startIndex + i];\r\n            IGameTableImplementation gameTable = IGameTableImplementation(tableAddr);\r\n            tables[resultCount - 1 - i] = gameTable.getTableInfoShort(); // 反向填充保持最新的在前\r\n        }\r\n        \r\n        return tables;\r\n    }\r\n\r\n    /**\r\n     * @dev 获取所有非活跃可被清算的游戏桌信息\r\n     * @return 返回游戏桌信息数组\r\n     */\r\n    function getAllGameTablesInactive() external view returns(GameTableInfoShort[] memory) {\r\n        uint256 tableCount = tableAddresses.length;\r\n        GameTableInfoShort[] memory tempTables = new GameTableInfoShort[](tableCount);\r\n        uint256 validCount = 0;\r\n\r\n        for (uint256 i = 0; i < tableCount; i++) {\r\n            address tableAddr = tableAddresses[i];\r\n            IGameTableImplementation gameTable = IGameTableImplementation(tableAddr);\r\n            //超过清算时间并且游戏在进行中的table可以被清算\r\n            if(gameTable.lastActivityTimestamp() + tableInactiveTimeout < block.timestamp &&\r\n            (gameTable.state() == GameState.FIRST_BETTING || gameTable.state() == GameState.SECOND_BETTING)){\r\n                tempTables[validCount] = gameTable.getTableInfoShort();\r\n                validCount++;\r\n            }\r\n        }\r\n\r\n        // 创建一个新的数组来存储有效元素\r\n        GameTableInfoShort[] memory tables = new GameTableInfoShort[](validCount);\r\n        for (uint256 i = 0; i < validCount; i++) {\r\n            tables[i] = tempTables[i];\r\n        }\r\n\r\n        return tables;\r\n    }\r\n\r\n    /**\r\n     * @dev 获取指定地址的游戏桌信息\r\n     * @param tableAddr 游戏桌合约地址\r\n     * @return 返回游戏桌信息\r\n     */\r\n    function getGameTableInfo(address tableAddr) external view returns (GameTableInfoShort memory) {\r\n        return _getTableInfo(tableAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev 获取我参与的赌桌\r\n     * @return 返回游戏桌信息\r\n     */\r\n    function getMyGameTables() external view returns (GameTableInfoShort[] memory) {\r\n        uint256 tableCount = userTables[msg.sender].length;\r\n        GameTableInfoShort[] memory tables = new GameTableInfoShort[](tableCount);\r\n\r\n        for (uint256 i = 0; i < tableCount; i++) {\r\n            address tableAddr = userTables[msg.sender][i];\r\n            tables[i] = _getTableInfo(tableAddr);\r\n        }\r\n\r\n        return tables;\r\n    }\r\n\r\n    // 添加一个内部函数来获取游戏桌信息\r\n    function _getTableInfo(address tableAddr) internal view returns (GameTableInfoShort memory) {\r\n        require(tableAddr != address(0) && gameTables[tableAddr] != address(0), \"Table does not exist\");\r\n        IGameTableImplementation gameTable = IGameTableImplementation(tableAddr);\r\n        return gameTable.getTableInfoShort();\r\n    }\r\n\r\n    // 验证游戏桌是否合法\r\n    function isValidGameTable(address tableAddr) external view returns (bool) {\r\n        return address(gameTables[tableAddr]) == tableAddr;\r\n    }\r\n\r\n    //设置奖励池合约地址\r\n    function setRewardPoolAddress(address _rewardPoolAddress) external onlyOwner nonReentrant{\r\n        require(_rewardPoolAddress != address(0), \"Invalid reward pool address\");\r\n        rewardPoolAddress = _rewardPoolAddress;\r\n    }\r\n\r\n    function rewardPoolIsInUse(address _bankerAddr, uint256 _poolId) external view returns (bool) {\r\n        address[] storage tableAddrs = userTables[_bankerAddr];\r\n\r\n        for (uint256 i = 0; i < tableAddrs.length; i++) {\r\n            address tableAddr = tableAddrs[i];\r\n            if (IGameTableImplementation(tableAddr).rewardPoolId() == _poolId) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev 设置游戏桌工厂合约地址\r\n     * @param _gameTableFactoryAddress 游戏桌工厂合约地址\r\n     */\r\n    function setGameTableFactoryAddress(address _gameTableFactoryAddress) external onlyOwner nonReentrant {\r\n        require(_gameTableFactoryAddress != address(0), \"Invalid game table factory address\");\r\n        gameTableFactoryAddress = _gameTableFactoryAddress;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev 设置房间等级合约地址\r\n     * @param _roomLevelAddress 房间等级合约地址\r\n     */\r\n    function setRoomLevelAddress(address _roomLevelAddress) external onlyOwner nonReentrant {\r\n        require(_roomLevelAddress != address(0), \"Invalid room level address\");\r\n        roomLevelAddress = _roomLevelAddress;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev 获取用户创建的房间数量\r\n     * @param userAddress 用户地址\r\n     * @return 用户创建的房间数量\r\n     */\r\n    function getUserCreatedRoomsCount(address userAddress) public view returns (uint256) {\r\n        return userCreatedRoomsCount[userAddress];\r\n    }\r\n\r\n\r\n\r\n    // 授权升级\r\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n    \r\n\r\n    /**\r\n     * @dev 需要接收资金的合约必须要实现的函数\r\n     */\r\n    receive() external payable {}\r\n\r\n    // 事件定义\r\n    event GameTableCreated(address indexed tableAddr, address indexed banker, uint256 betAmount, uint8 maxPlayers, uint256 bankerFeePercent);\r\n    event GameTableRemoved(address indexed tableAddr);\r\n    event GameConfigUpdated(uint256 minBet, uint8 maxPlayers);\r\n}\r\n\r\n"
    },
    "contracts/BBGameTableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\r\n\r\n/**\r\n * Beacon 合约，用于指向可升级的实现合约\r\n */\r\ncontract BBGameTableBeacon is UpgradeableBeacon {\r\n    constructor(address implementation, address owner) UpgradeableBeacon(implementation, owner) {}\r\n}\r\n"
    },
    "contracts/BBGameTableFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\r\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./BBInterfaces.sol\";\r\n\r\n/**\r\n * @title BBGameTableFactory\r\n * @dev 游戏桌工厂合约，使用信标代理模式创建游戏桌\r\n */\r\ncontract BBGameTableFactory is Initializable, OwnableUpgradeable, UUPSUpgradeable {\r\n    // 信标合约地址\r\n    address public beacon;\r\n    \r\n    // 版本号，用于跟踪实现合约的版本\r\n    uint256 public version;\r\n    \r\n    // 事件\r\n    event ImplementationUpdated(address indexed oldImpl, address indexed newImpl, uint256 version);\r\n    \r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n    \r\n    function initialize(address _beacon) public initializer {\r\n        __Ownable_init(msg.sender);\r\n        __UUPSUpgradeable_init();\r\n        \r\n        beacon = _beacon;\r\n        version = 1;\r\n    }\r\n    \r\n    /**\r\n     * @dev 更新实现合约地址（通过信标）\r\n     * @param _implementation 新的实现合约地址\r\n     */\r\n    function updateImplementation(address _implementation) external onlyOwner {\r\n        require(_implementation != address(0), \"Invalid implementation address\");\r\n        \r\n        // 获取当前实现地址\r\n        address oldImpl = UpgradeableBeacon(beacon).implementation();\r\n        \r\n        // 更新信标中的实现地址\r\n        UpgradeableBeacon(beacon).upgradeTo(_implementation);\r\n        \r\n        version++;\r\n        \r\n        emit ImplementationUpdated(oldImpl, _implementation, version);\r\n    }\r\n    \r\n    /**\r\n     * @dev 创建游戏桌\r\n     * @param tableId 游戏桌ID\r\n     * @param tableName 游戏桌名称\r\n     * @param bankerAddr 庄家地址\r\n     * @param betAmount 下注金额\r\n     * @param maxPlayers 最大玩家数\r\n     * @param gameMainAddr 游戏主合约地址\r\n     * @param bankerFeePercent 庄家费用百分比\r\n     * @param firstRaise 第一轮下注倍数\r\n     * @param secondRaise 第二轮下注倍数\r\n     * @return 新创建的游戏桌地址\r\n     */\r\n    function createGameTable(\r\n        uint256 tableId,\r\n        string memory tableName,\r\n        address bankerAddr,\r\n        uint256 betAmount,\r\n        uint8 maxPlayers,\r\n        address gameMainAddr,\r\n        uint8 bankerFeePercent,\r\n        uint8 firstRaise,\r\n        uint8 secondRaise\r\n    ) external returns (address) {\r\n        // 准备初始化数据\r\n        bytes memory initData = abi.encodeWithSelector(\r\n            IGameTableImplementation.initialize.selector,\r\n            tableId,\r\n            tableName,\r\n            bankerAddr,\r\n            betAmount,\r\n            maxPlayers,\r\n            gameMainAddr,\r\n            bankerFeePercent,\r\n            firstRaise,\r\n            secondRaise,\r\n            version\r\n        );\r\n        \r\n        // 创建指向信标的代理\r\n        BeaconProxy proxy = new BeaconProxy(beacon, initData);\r\n        \r\n        return address(proxy);\r\n    }\r\n    \r\n    /**\r\n     * @dev 授权升级\r\n     */\r\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n}"
    },
    "contracts/BBGameTableImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./BBCardUtils.sol\";\nimport \"./BBPlayer.sol\";\nimport \"./BBTypes.sol\";\nimport \"./BBCardDealer.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n// import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./BBInterfaces.sol\";\n\n/**\n * @title BBGameTableImplementation\n * @dev 牛牛游戏桌实现合约，管理单个游戏桌的逻辑\n */\ncontract BBGameTableImplementation is ReentrancyGuard, Ownable {\n    using BBPlayerLib for BBPlayer;\n    using BBCardUtils for uint8[5];\n    using BBCardDealer for BBCardDealer.DealerState;\n\n    // 游戏桌数据\n    bool public active;\n    uint256 public tableId; // 游戏桌ID\n    string public tableName;\n    address public bankerAddr;\n    uint256 public betAmount;  // 固定押注金额\n    uint8 public playerCount;\n    uint8 public maxPlayers;\n    uint256 public creationTimestamp;\n    GameState public state;\n    uint256 public rewardPoolId;\n    uint256 public bankerStakeAmount;  //庄家的押金\n    uint256 public totalIncome; // 总收入\n\n    // 第一、二轮下注金额是第一轮的倍数，默认2\n    uint8 public firstBetX;\n    uint8 public secondBetX;\n\n    uint256 public gameRound; //游戏场次\n    uint256 public gameLiquidatedCount; //被清算的游戏场数\n\n    uint256 public finalSeed; // 最后一次使用的种子\n\n    uint256 public gameStartTimestamp;\n    uint256 public gameEndTimestamp;\n    uint8 public playerContinuedCount;\n    uint8 public playerReadyCount;\n    uint256 public totalPrizePool;  //奖池金额\n    uint8 public bankerFeePercent; // 庄家费用百分比\n    uint8 public liquidatorFeePercent; // 清算人费用百分比\n    uint256 public implementationVersion; // 实现版本号\n\n    // 玩家数据\n    BBPlayer[] public players;\n\n    // 发牌记录\n    BBCardDealer.DealerState private dealerState;\n\n    //主合约地址\n    address public gameMainAddr;\n    address public rewardPoolAddr; // 奖励池合约地址\n    address public roomCardAddr; // 房间卡合约地址\n\n    // 添加超时相关状态变量\n    uint256 public playerTimeout; // 玩家操作超时时间，单位为秒\n    uint256 public currentRoundDeadline; // 当前回合的截止时间\n\n    uint256 public tableInactiveTimeout; // 游戏桌不活跃超时时间，单位为秒\n    uint256 public lastActivityTimestamp; // 最后活动时间戳\n\n    //庄家奖励\n    address public rewardAddr; // 奖励地址\n    uint256 public rewardAmount; // 奖励金额\n\n    string public chatGroupId; // 聊天组ID\n\n    // 预留 50 个 slot 给将来新增变量用，防止存储冲突\n    uint256[50] private __gap;\n\n    // 事件\n    event GameTableChanged(address indexed tableAddr);\n    event GameTableInitialized(address indexed tableAddr, address indexed banker, uint256 version);\n    event CreateGameHistory(address indexed tableAddr, uint256 round, uint256 gameStartTimestamp, uint256 gameEndTimestamp, address[] playerAddrs, address[] winnerAddrs, uint256[] playerBets, uint8[5][] playerCards);\n\n\n    // 修改构造函数，传入初始所有者\n    constructor() Ownable(msg.sender){\n        // 构造函数体可以为空，因为所有权已经在 Ownable 构造函数中设置\n    }\n   \n    /**\n     * @dev 初始化函数，替代构造函数\n     */\n    function initialize(\n        uint256 _tableId,\n        string memory _tableName,\n        address _bankerAddr,\n        uint256 _betAmount,\n        uint8 _maxPlayers,\n        address _gameMainAddr,\n        uint8 _bankerFeePercent,\n        uint8 _firstRaise,\n        uint8 _secondRaise,\n        uint256 _implementationVersion\n    ) external {\n        // 确保只初始化一次的检查\n        require(creationTimestamp == 0, \"Already initialized\");\n        \n        _transferOwnership(_gameMainAddr);\n\n        // 参数验证\n        require(_maxPlayers >= 2, \"Invalid max players\");\n\n        active = true;\n        tableId = _tableId;\n        tableName = _tableName;\n        bankerAddr = _bankerAddr;\n        betAmount = _betAmount;\n        maxPlayers = _maxPlayers;\n        state = GameState.WAITING;\n        gameMainAddr = _gameMainAddr;\n        creationTimestamp = block.timestamp;\n        lastActivityTimestamp = block.timestamp; // 初始化最后活动时间\n        bankerFeePercent = _bankerFeePercent;\n        implementationVersion = _implementationVersion;\n\n        firstBetX = _firstRaise;\n        secondBetX = _secondRaise;\n\n\n        refreshConfig();\n\n        emit GameTableInitialized(address(this), _bankerAddr, _implementationVersion);\n    }\n\n    //刷新游戏配置\n    function refreshConfig() internal {\n        IGameMain gameMain = IGameMain(gameMainAddr);\n        GameConfig memory config = gameMain.getGameConfig();\n        playerTimeout = config.playerTimeout * playerCount;\n        liquidatorFeePercent = config.liquidatorFeePercent;\n        tableInactiveTimeout = config.tableInactiveTimeout;\n        roomCardAddr = config.roomCardAddress;\n        rewardPoolAddr = config.rewardPoolAddress;\n    }\n\n    // 添加一个公共函数来获取玩家地址列表，数组需要显示定义get函数，int、string等不需要\n    function getPlayerAddresses() public view returns (address[] memory) {\n        // 如果没有玩家，直接返回空数组\n        if (playerCount == 0) {\n            return new address[](0);\n        }\n\n        address[] memory playerAddresses = new address[](playerCount);\n        uint count = 0;\n        for(uint i = 0; i < players.length; i++){\n            if(players[i].addr != address(0)){\n                playerAddresses[count] = players[i].addr;\n                count++;\n            }\n        }\n\n        return playerAddresses;\n    }\n\n    // 添加编辑table的函数\n    function editGameTable(\n        string memory _tableName,\n        uint256 _betAmount,\n        uint8 _maxPlayers,\n        uint8 _bankerFeePercent,\n        uint8 _firstRaise,\n        uint8 _secondRaise\n    ) external onlyBanker nonReentrant {\n        IGameMain gameMain = IGameMain(gameMainAddr);\n        GameConfig memory config = gameMain.getGameConfig();\n        \n        require(_betAmount != 0, \"Bet amount too small\");\n        require(_maxPlayers > 0 && _maxPlayers <= config.maxPlayers, \"Invalid max players\");\n        require(_bankerFeePercent <= config.maxBankerFeePercent, \"Invalid banker fee percent\");\n        require(bytes(_tableName).length > 0 && bytes(_tableName).length <= 20, \"Invalid table name\");\n        require(_firstRaise >= 1 && _firstRaise <= 4, \"Invalid first raise\");\n        require(_secondRaise >= 1 && _secondRaise <= 4, \"Invalid second raise\");\n        \n        tableName = _tableName;\n        betAmount = _betAmount;\n        maxPlayers = _maxPlayers;\n        bankerFeePercent = _bankerFeePercent;\n        firstBetX = _firstRaise;\n        secondBetX = _secondRaise;\n        \n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 更新最后活动时间\n     */\n    function _updateLastActivity() internal {\n        lastActivityTimestamp = block.timestamp;\n    }\n\n    modifier onlyParticipant() {\n        if(msg.sender != bankerAddr) {\n            _getPlayer(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @dev 修饰器：适用于庄家\n     */\n    modifier onlyBanker() {\n        require(msg.sender == bankerAddr, \"not banker\");\n        _;\n    }\n\n    /**\n     * @dev 修饰器：适用于玩游戏的玩家，如果庄家也参与游戏，那也算在内\n     */\n    modifier onlyPlayers() {\n        _getPlayer(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev 修饰器：只允许游戏主合约调用\n     */\n    modifier onlyGameMain() {\n        require(msg.sender == gameMainAddr, \"only main contract can call\");\n        _;\n    }\n\n\n    /**\n     * @dev 庄家为游戏桌设置奖励池\n     * @param poolId 奖励池ID\n     */\n    function setTableRewardPool(uint256 poolId) external onlyBanker nonReentrant {\n        require(rewardPoolAddr != address(0), \"Invalid reward pool address\");\n        bool isBankerPool = IRewardPool(rewardPoolAddr).isBankerPool(bankerAddr, poolId);\n        require(isBankerPool, \"poolId is not your pool\");\n\n        rewardPoolId = poolId;\n    }\n\n    /**\n     * @dev 庄家移除游戏桌的奖励池\n     */\n    function removeTableRewardPool() external onlyBanker nonReentrant {\n        rewardPoolId = 0;\n    }\n\n    //添加玩家\n    function _addPlayer(address playerAddr) internal returns (uint256) {\n        //遍历players找到空闲的位置\n        for(uint8 i = 0; i < players.length; i++){\n            if(players[i].addr == address(0)){\n                players[i].addr = playerAddr;\n                players[i].state = PlayerState.JOINED;\n                players[i].totalBet = 0;\n                players[i].hasActedThisRound = false;\n                players[i].cards = [0, 0, 0, 0, 0];\n                players[i].cardType = CardType.NONE;\n                playerCount++;\n                return i;\n            }\n        }\n\n        players.push(BBPlayer({\n            addr: playerAddr,\n            state: PlayerState.JOINED,\n            totalBet: 0,\n            hasActedThisRound: false,\n            isWinner: false,\n            cards: [0, 0, 0, 0, 0],\n            cardType: CardType.NONE,\n            __gap: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)]\n        })); \n\n        playerCount++;\n        return players.length - 1;   \n    }\n\n    function _getPlayerIndex(address playerAddr) internal view returns (uint8) {\n        for (uint8 i = 0; i < players.length; i++) {\n            if (players[i].addr == playerAddr) {\n                return i;\n            }\n        }\n        require(false, \"Player not found\");\n        return 0;\n    }\n\n    function _getPlayer(address playerAddr) internal view returns (uint8 index, BBPlayer storage) {\n        uint8 playerIndex = _getPlayerIndex(playerAddr);\n        return (playerIndex, players[playerIndex]);\n    }\n\n    //移除玩家\n    function _removePlayer(address playerAddr) internal {\n        uint8 index = _getPlayerIndex(playerAddr);\n        _removePlayerByIndex(index);\n    }\n\n    function _removePlayerByIndex(uint8 index) internal {\n        players[index].addr = address(0);\n        players[index].state = PlayerState.NONE;\n        players[index].totalBet = 0;\n        players[index].hasActedThisRound = false;\n        players[index].isWinner = false;\n        players[index].cards = [0, 0, 0, 0, 0];\n        players[index].cardType = CardType.NONE;\n\n        playerCount--;\n    }\n\n    function _isPlayerExists(address playerAddr) internal view returns (bool) {\n        for (uint8 i = 0; i < players.length; i++) {\n            if (players[i].isValid() && players[i].addr == playerAddr) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // 更新聊天群组ID\n    function updateChatGroupId(string memory _chatGroupId) external onlyBanker {\n        chatGroupId = _chatGroupId;\n    }\n\n\n    /**\n     * @dev 玩家加入游戏\n     */\n    function playerJoin() external nonReentrant {\n        address playerAddr = msg.sender;\n        require(!_isPlayerExists(playerAddr), \"Player already joined\");\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        require(playerCount < maxPlayers, \"Max players reached\");\n\n        _addPlayer(playerAddr);\n\n        _updateLastActivity();\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家准备\n     */\n    function playerReady(bytes32 randomValue) external payable onlyPlayers nonReentrant {\n        require(randomValue != bytes32(0), \"Invalid random value\");\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        address playerAddr = msg.sender;\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.JOINED, \"Player not in joined state\");\n        require(msg.value == betAmount, \"Insufficient funds\");\n\n        player.totalBet = betAmount;\n        totalPrizePool += betAmount;\n        playerReadyCount++;\n\n        player.playerReady();\n\n        _updateLastActivity();\n\n        _updateFinalSeed(randomValue);\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家取消准备\n     */\n    function playerUnready() external payable onlyPlayers nonReentrant {\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        address playerAddr = msg.sender;\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.READY, \"Player not in ready state\");\n\n        totalPrizePool -= betAmount;\n        playerReadyCount--;\n        player.totalBet = 0;\n\n        player.playerUnready();\n\n        _updateLastActivity();\n\n        // 返还押金给玩家 - 使用更安全的 call 方法而不是 transfer\n        (bool success, ) = payable(playerAddr).call{value: betAmount}(\"\");\n        require(success, \"transfer failed\");\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家退出游戏\n     */\n    function playerQuit() external payable onlyPlayers nonReentrant {\n        require(state == GameState.WAITING || state == GameState.SETTLED, \"Game not in waiting or settled state\");\n        address playerAddr = msg.sender;\n        (uint8 playerIndex, BBPlayer storage player) = _getPlayer(playerAddr);\n        if(state == GameState.WAITING){\n            require(player.state == PlayerState.JOINED || player.state == PlayerState.READY, \"Player not in JOINED or READY state\");\n\n            // 先保存需要返还的金额\n            uint256 amountToReturn = player.totalBet;\n\n            if(player.state == PlayerState.READY){\n                playerReadyCount--;\n                totalPrizePool -= amountToReturn;\n            }\n\n            // 移除玩家\n            _removePlayerByIndex(playerIndex);\n\n            if(amountToReturn > 0){\n                //返还押金\n                (bool success, ) = payable(playerAddr).call{value: amountToReturn}(\"\");\n                require(success, \"transfer failed\");\n            }\n        }else{\n            // 移除玩家\n            _removePlayerByIndex(playerIndex);\n        }  \n        \n\n        _updateLastActivity();\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 庄家移除玩家\n     */\n    function bankerRemovePlayer(address playerAddr) external onlyBanker nonReentrant {\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        require(playerAddr != bankerAddr, \"Can not remove banker\");\n        (uint8 playerIndex, BBPlayer storage player) = _getPlayer(playerAddr);\n\n\n        uint256 amountToReturn = 0;\n        if(player.totalBet > 0){\n            amountToReturn = player.totalBet;\n        }\n        if(player.state == PlayerState.READY){\n            playerReadyCount--;\n            totalPrizePool -= amountToReturn;\n        }\n        _removePlayerByIndex(playerIndex);\n        _updateLastActivity();\n\n        // 最后进行转账\n        if(amountToReturn > 0){\n            (bool success, ) = payable(playerAddr).call{value: amountToReturn}(\"\");\n            require(success, \"transfer failed\");\n        }\n\n\n        emit GameTableChanged(address(this));\n    }\n\n    function _updateFinalSeed(bytes32 randomValue) internal {\n        finalSeed = uint256(keccak256(abi.encodePacked(\n            finalSeed,\n            block.prevrandao,\n            block.timestamp,\n            msg.sender,\n            randomValue\n        )));\n    }\n\n    function startGame(uint256 roomCardId, bytes32 randomValue) external payable onlyBanker nonReentrant {\n        require(randomValue!= bytes32(0), \"Invalid random value\");\n        // 刷新游戏数据\n        refreshConfig();\n\n        require(roomCardId != 0, \"Invalid room card params\");\n        require(roomCardAddr != address(0), \"Invalid room card contract\");\n        require(playerReadyCount == playerCount, \"Not all players ready\");\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        require(playerCount >= 2, \"Not enough players\");\n\n        // 庄家需要押金\n        require(msg.value == betAmount, \"Insufficient funds\");\n        bankerStakeAmount = betAmount;\n\n        //验证房卡\n        IRoomCardNFT roomCard = IRoomCardNFT(roomCardAddr);\n        require(roomCard.validateParams(roomCardId, playerCount), \"Invalid room card params\");\n \n        // 消耗房卡\n        roomCard.consume(msg.sender, roomCardId);\n        \n        gameRound++;\n\n        _updateFinalSeed(randomValue);\n\n        _startFirstBetting();\n    }\n\n    function _resetGame() internal {\n        playerContinuedCount = 0;\n        gameStartTimestamp = 0;\n        gameEndTimestamp = 0;\n        currentRoundDeadline = 0;\n        playerReadyCount = 0;\n        totalPrizePool = 0;\n        rewardAddr = address(0);\n        rewardAmount = 0;\n        dealerState.reset();\n        for(uint i = 0; i < players.length; i++){\n            if(players[i].isValid()){\n                players[i].playerReset();\n            }  \n        }\n        setState(GameState.WAITING);\n    }\n\n    function _canSettleGame() internal view returns (bool) {\n        if(state == GameState.WAITING || state == GameState.SETTLED || state == GameState.LIQUIDATED){\n            return false;\n        }\n        if(state == GameState.ENDED){\n            return true;\n        }\n\n\n        if(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING){\n            (uint8 foldedCount, uint8 totalActed) = _getPlayerActionCounts();\n\n            bool onlyOneLeft = playerContinuedCount == 1 && foldedCount == playerCount - 1;\n            bool noOneLeft = foldedCount == playerCount;\n            bool isDeadlinePassed = _isTimeOut();\n            bool noOneActed = totalActed == 0;\n            bool lessOneContinued = playerContinuedCount <= 1;  //小于等于一个人继续\n\n            if (onlyOneLeft || noOneLeft || (isDeadlinePassed && lessOneContinued) || (isDeadlinePassed && noOneActed)) {\n                // 可以结算\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev 下一步\n     */\n    function nextStep(bytes32 randomValue) external onlyBanker nonReentrant {\n        require(randomValue != bytes32(0), \"Invalid random value\");\n        if(_canSettleGame()){\n            _settleGame();\n\n            _updateFinalSeed(randomValue);\n            _updateLastActivity();\n            emit GameTableChanged(address(this));\n            return;\n        }\n        \n        (bool canMove, , string memory reason) = canMoveToNextStep();\n        require(canMove, reason);\n        if(state == GameState.FIRST_BETTING) {\n            _startSecondBetting();\n        }\n        else if(state == GameState.SECOND_BETTING) {\n            _endGame();\n        }\n        else if(state == GameState.SETTLED) {\n            _resetGame();\n        }\n\n        // 将所有人设置为未操作状态\n        for(uint i = 0; i < players.length; i++){\n            if(players[i].isValid()){\n                players[i].hasActedThisRound = false;\n            }\n        }\n        \n        _updateFinalSeed(randomValue);\n        _updateLastActivity();\n        emit GameTableChanged(address(this));\n    }\n\n    function _dealCardsByRound(uint8 round) internal {\n        dealerState.initialize(finalSeed);\n        if(round == 1){\n            // 第一轮发牌，每个玩家发3张牌\n            for(uint i = 0; i < players.length; i++){\n                if(players[i].isValid()){\n                    uint8[] memory newCards = dealerState.dealCardsByRoundForPlayer(players[i].addr, round);\n                    for(uint j = 0; j < 3; j++){\n                        players[i].cards[j] = newCards[j];\n                    }\n                }\n            }\n        }else{\n            // 第二、三轮发牌\n            for(uint i = 0; i < players.length; i++){\n                if(players[i].isValid() && players[i].state == PlayerState.ACTIVE){\n                    uint8[] memory newCards = dealerState.dealCardsByRoundForPlayer(players[i].addr, round);\n                    // 合并第一轮和第二轮的牌\n                    for(uint j = 0; j < newCards.length; j++){\n                        players[i].cards[j + round + 1] = newCards[j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev 检查揭示阶段状态，如果所有玩家都已揭示或超时，完成会话并进入下注阶段\n     */\n    function _startFirstBetting() internal {\n        // 将所有玩家设置成active状态\n        for (uint256 i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                player.state = PlayerState.ACTIVE;\n            }\n        }\n\n        // 初始化发牌状态\n        dealerState.reset();\n\n        // 第一轮发牌\n        _dealCardsByRound(1);\n\n        // 进入第一轮下注\n        setState(GameState.FIRST_BETTING);\n    }\n\n    function _getPlayerActionCounts() internal view returns (uint8, uint8){\n        uint8 foldedCount = 0;\n        uint8 actedCount = 0;\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                if(player.state == PlayerState.FOLDED){\n                    foldedCount++;\n                }\n                if(player.hasActedThisRound){\n                    actedCount++;\n                }\n            }\n        }\n\n        return (foldedCount, actedCount);\n    }\n\n    \n\n    function _startSecondBetting() internal {\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid() && !player.hasActedThisRound){\n                player.playerFold();\n            }\n        }\n\n        _dealCardsByRound(2);\n        setState(GameState.SECOND_BETTING);\n        playerContinuedCount = 0;\n    }\n\n    function _endGame() internal {\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid() && !player.hasActedThisRound){\n                player.playerFold();\n            }\n        }\n\n        _dealCardsByRound(3);\n        setState(GameState.ENDED);\n        _settleGame();\n    }\n\n    function _allPlayersActed() public view returns (bool){\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                if(player.state != PlayerState.FOLDED && !player.hasActedThisRound){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function canMoveToNextStep() public view returns (bool canMove, string memory title, string memory reason) {\n        if (state == GameState.LIQUIDATED) {\n            return (false, \"\", \"Game has been liquidated\");\n        }else if(state == GameState.SETTLED){\n            return (true, \"Play Again\", \"\");\n        }else if (state == GameState.ENDED) {\n            return (true, \"Settle Game\", \"\");\n        }else if(state == GameState.SETTLED){\n            return (true, \"Play Again\", \"\");\n        }else if (state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING) {\n\n            if (playerCount == 0) {\n                // 如果没有玩家，直接返回\n                return (false, \"\", \"No players in game\");\n            }\n\n            bool isDeadlinePassed = _isTimeOut();\n            bool allPlayersActed = _allPlayersActed();\n\n            if (_canSettleGame()) {\n                return (true, \"Settle Game\", \"\");\n            } else if (allPlayersActed || isDeadlinePassed) {\n                return (true, \"Next Round\", \"\");\n            } else {\n                return (false, \"Next Round\", \"Waiting for players to act\");\n            }\n        }\n\n        return (false, \"\", \"Unknown state\");\n    }\n\n\n    function _isTimeOut() internal view returns (bool) {\n        return currentRoundDeadline > 0 && block.timestamp > currentRoundDeadline;\n    }\n\n    /**\n     * @dev 玩家弃牌\n     */\n    function playerFold(bytes32 randomValue) external onlyPlayers nonReentrant{\n        require(randomValue!= bytes32(0), \"Invalid random value\");\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Game not in playing state\");\n        address playerAddr = msg.sender;\n\n        // 检查是否超时\n        require(!_isTimeOut(), \"action timeout\");\n\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.ACTIVE && player.hasActedThisRound == false, \"Player not in active state or has acted\");\n\n        _updateLastActivity();\n        player.playerFold();\n\n        _updateFinalSeed(randomValue);\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家继续游戏\n     */\n    function playerContinue(bytes32 randomValue) external payable onlyPlayers nonReentrant{\n        require(randomValue!= bytes32(0), \"Invalid random value\");\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Game not in playing state\");\n        address playerAddr = msg.sender;\n\n        uint256 needBetAmount = 0;\n\n        if(state == GameState.FIRST_BETTING){\n            needBetAmount = betAmount * firstBetX;\n        }else{\n            needBetAmount = betAmount * secondBetX;\n        }\n\n        require(msg.value == needBetAmount, \"Insufficient funds\");\n\n        // 检查是否超时\n        require(!_isTimeOut(), \"action timeout\");\n\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.ACTIVE && player.hasActedThisRound == false, \"Player not in active state or has acted\");\n\n        player.playerContinue(needBetAmount);\n        playerContinuedCount++;\n        totalPrizePool += needBetAmount;\n\n        _updateLastActivity();\n\n        _updateFinalSeed(randomValue);\n\n        emit GameTableChanged(address(this));\n    }\n\n    function _gameTimeout() internal view returns (bool)  {\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Game not in playing state\"); \n\n        // 检查是否超时\n        return block.timestamp > lastActivityTimestamp + tableInactiveTimeout;\n    }\n\n    /**\n     * @dev 玩家结算游戏，如果庄家没结算的话\n     */\n    function playerSettle() external payable onlyPlayers nonReentrant{\n        require(_gameTimeout(), \"Game not timeout\");\n\n        _settleGame();\n    }\n\n    function _settleGame() internal {\n        setState(GameState.SETTLED);\n\n        gameEndTimestamp = block.timestamp;\n\n\n        bool noOneContinued = playerContinuedCount == 0;\n\n        // 计算费用\n        uint256 bankerFee = (totalPrizePool * bankerFeePercent) / 100;\n        if(noOneContinued){\n            // 如果没有人继续，庄家不收取费用\n            bankerFee = 0;\n        }\n        uint256 remainingPrizePool = totalPrizePool - bankerFee;\n\n        uint256 bankerTotal = bankerFee + bankerStakeAmount;\n        bankerStakeAmount = 0;\n\n        // 如果只有一个玩家继续，则该玩家获胜\n        if (playerContinuedCount == 1) {\n            _settleOneContinuedPlayer(remainingPrizePool);\n        }\n        // 如果没有人继续，则每个人拿回自己的钱\n        else if (noOneContinued) {\n            _settleAllFolded();\n        }\n        // 正常比牌\n        else {\n            _settleNormalGame(remainingPrizePool);\n        }\n\n        // 统一处理庄家费用转账，庄家抽成+庄家押金\n        if (bankerTotal > 0) {\n            totalIncome += bankerFee;\n            (bool success, ) = payable(bankerAddr).call{value: bankerTotal}(\"\");\n            require(success, \"transfer to banker failed\");\n        }\n\n        // 如果设置了奖励池，尝试分配奖励\n        if (rewardPoolAddr != address(0) && rewardPoolId != 0) {\n            address[] memory playerAddresses = getPlayerAddresses();\n            IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n            try rewardPool.tryDistributeReward(rewardPoolId, playerAddresses, finalSeed) returns (address winAddr, uint256 winAmount){\n                if(winAddr != address(0)){\n                    // 有人获奖，设置获奖的人信息\n                    rewardAddr = winAddr;\n                    rewardAmount = winAmount;\n                }\n            } catch {\n            }\n        }\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 处理只有一个玩家继续的情况\n     */\n    function _settleOneContinuedPlayer(uint256 remainingPrizePool) internal {\n        // 准备游戏结果数据\n        address[] memory winnerAddrs = new address[](1);\n        uint256[] memory playerBets = new uint256[](playerCount);\n        uint8[5][] memory playerCards = new uint8[5][](playerCount);\n        address[] memory playerAddresses = new address[](playerCount);\n        uint256 winnerCount = 0;\n\n        // 找出继续的那个玩家\n        address continuedPlayer = address(0);\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if (player.isValid()) {\n                // 找出继续的玩家\n                if (player.state == PlayerState.ACTIVE &&\n                    player.hasActedThisRound) {\n                    continuedPlayer = player.addr;\n                    winnerAddrs[winnerCount] = player.addr;\n                    player.isWinner = true;\n                    winnerCount++;\n                }\n\n                playerBets[index] = player.totalBet;\n                playerCards[index] = player.cards;\n                playerAddresses[index] = player.addr;\n\n                index++;\n            }\n        }\n\n        // 将剩余奖池给获胜者\n        if (continuedPlayer != address(0)) {\n            (bool success, ) = payable(continuedPlayer).call{value: remainingPrizePool}(\"\");\n            require(success, \"transfer to winners failed\");\n        }\n\n        emit CreateGameHistory(address(this), gameRound, gameStartTimestamp, gameEndTimestamp, playerAddresses, winnerAddrs, playerBets, playerCards);\n    }\n\n    /**\n     * @dev 处理所有玩家都弃牌的情况\n     */\n    function _settleAllFolded() internal {\n        // 创建临时数组来存储需要返还资金的玩家和金额\n        address[] memory refundAddresses = new address[](playerCount);\n        uint256[] memory refundAmounts = new uint256[](playerCount);\n        uint256[] memory playerBets = new uint256[](playerCount);\n        uint8[5][] memory playerCards = new uint8[5][](playerCount);\n        address[] memory playerAddresses = new address[](playerCount);\n        address[] memory winnerAddrs = new address[](0);\n        uint256 refundCount = 0;\n\n        // 收集所有玩家数据并计算需要返还的金额\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            if (players[i].isValid()) {\n                BBPlayer storage player = players[i];\n\n                // 计算需要返还的金额（玩家的所有押注）\n                uint256 refundAmount = player.totalBet;\n                if (refundAmount > 0) {\n                    refundAddresses[refundCount] = player.addr;\n                    refundAmounts[refundCount] = refundAmount;\n                    refundCount++;\n                }\n\n                playerBets[index] = players[i].totalBet;\n                playerCards[index] = players[i].cards;\n                playerAddresses[index] = players[i].addr;\n                index++;\n            }        \n        }\n\n        // 返还每个玩家的押注\n        for (uint i = 0; i < refundCount; i++) {\n            (bool success, ) = payable(refundAddresses[i]).call{value: refundAmounts[i]}(\"\");\n            require(success, \"refund failed\");\n        }\n\n        emit CreateGameHistory(address(this), gameRound, gameStartTimestamp, gameEndTimestamp, playerAddresses, winnerAddrs, playerBets, playerCards);\n    }\n\n\n    /**\n     * @dev 处理正常比牌的情况\n     */\n    function _settleNormalGame(uint256 remainingPrizePool) internal {\n        CardType _maxCardType = CardType.NONE;\n\n        // 准备游戏结果数据\n        address[] memory winnerAddrs = new address[](playerCount);\n        uint256[] memory playerBets = new uint256[](playerCount);\n        uint8[5][] memory playerCards = new uint8[5][](playerCount);\n        address[] memory playerAddresses = new address[](playerCount);\n        uint256 winnerCount = 0;\n\n\n        // 计算每个玩家的牌型\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if (player.isValid()) {\n                player.cardType = BBCardUtils.calculateCardType(player.cards);\n                // 更新最大牌型\n                if (uint8(player.cardType) > uint8(_maxCardType)) {\n                    _maxCardType = player.cardType;\n                }\n\n                playerBets[index] = player.totalBet;\n                playerCards[index] = player.cards;\n                playerAddresses[index] = player.addr;\n                index++;\n            }\n        }\n\n        // 如果所有玩家都没有牛牌型，则比较最大牌\n        if (_maxCardType == CardType.NONE) {\n            (winnerAddrs, winnerCount) = _settleNormalGameWithNoBull();\n        } else {\n            // 找出获胜者（有牛牌型的情况）\n            for (uint i = 0; i < players.length; i++) {\n                BBPlayer storage player = players[i];\n                if (player.isValid()) {\n                    // 如果是获胜者，添加到获胜者数组\n                    if (player.cardType == _maxCardType) {\n                        winnerAddrs[winnerCount] = player.addr;\n                        player.isWinner = true;\n                        winnerCount++;\n                    }\n                }\n            }\n        }\n\n        // 调整获胜者数组大小\n        assembly (\"memory-safe\")  {\n            mstore(winnerAddrs, winnerCount)\n        }\n\n\n        // 分配奖金给获胜者\n        if (winnerCount > 0) {\n            // 每个获胜者应得的奖金\n            uint256 prizePerWinner = remainingPrizePool / winnerCount;\n\n            // 分配奖金给每个获胜者\n            for (uint i = 0; i < winnerCount; i++) {\n                address winnerAddr = winnerAddrs[i];\n                (bool success, ) = payable(winnerAddr).call{value: prizePerWinner}(\"\");\n                require(success, \"transfer to winners failed\");\n            }\n\n            // 处理可能的舍入误差，将剩余的少量奖金给第一个获胜者\n            uint256 remainingPrize = remainingPrizePool - (prizePerWinner * winnerCount);\n            if (remainingPrize > 0) {\n                (bool success, ) = payable(winnerAddrs[0]).call{value: remainingPrize}(\"\");\n                require(success, \"transfer to winners failed\");\n            }\n        }\n\n        emit CreateGameHistory(address(this), gameRound, gameStartTimestamp, gameEndTimestamp, playerAddresses, winnerAddrs, playerBets, playerCards);\n    }\n\n    /**\n     * @dev 处理没有牛牌型的情况\n     */\n    function _settleNormalGameWithNoBull() internal view returns (address[] memory, uint256){\n        uint8 maxCard = 0;\n        uint256 winnerCount = 0;\n        address[] memory winnerAddrs = new address[](playerCount);\n\n        // 先找出所有玩家中的最大牌\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                // 找出玩家五张牌中的最大牌\n                uint8 playerMaxCard = 0;\n                for (uint j = 0; j < 5; j++) {\n                    uint8 cardValue = player.cards[j] % 13;\n                    // 修正：A是最小的(值为1)，K是最大的(值为13)\n                    if (cardValue == 0) cardValue = 1; // A的值为1\n                    if (cardValue > playerMaxCard) {\n                        playerMaxCard = cardValue;\n                    }\n                }\n\n                // 更新全局最大牌\n                if (playerMaxCard > maxCard) {\n                    maxCard = playerMaxCard;\n                }\n            }\n        }\n\n        // 找出拥有最大牌的玩家\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                // 检查玩家是否有最大牌\n                uint8 playerMaxCard = 0;\n                for (uint j = 0; j < 5; j++) {\n                    uint8 cardValue = player.cards[j] % 13;\n                    // 修正：A是最小的(值为1)，K是最大的(值为13)\n                    if (cardValue == 0) cardValue = 1; // A的值为1\n                    if (cardValue > playerMaxCard) {\n                        playerMaxCard = cardValue;\n                    }\n                }\n\n                if (playerMaxCard == maxCard) {\n                    winnerAddrs[winnerCount] = player.addr;\n                    winnerCount++;\n                }\n            }  \n        }\n\n        // 调整获胜者数组大小\n        assembly (\"memory-safe\")  {\n            mstore(winnerAddrs, winnerCount)\n        }\n\n        return (winnerAddrs, winnerCount);\n    }\n\n    /**\n     * @dev 清算不活跃的游戏桌\n     * 此函数来清算长时间不活跃的游戏桌\n     * 庄家的押金将被分配给玩家和清算人\n     */\n    function liquidateInactiveTable() external onlyPlayers nonReentrant {\n        // 检查游戏桌是否超时\n        require(block.timestamp > lastActivityTimestamp + tableInactiveTimeout, \"Table not inactive\");\n        require(msg.sender != bankerAddr, \"Banker cannot liquidate\");\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Table not in gaming\");\n\n        // 清算人的奖励 (从庄家押金中收取)\n        uint256 liquidatorReward = bankerStakeAmount * liquidatorFeePercent / 100;\n\n        // 剩余的庄家押金平均分配给所有玩家\n        uint256 remainingBankerBet = bankerStakeAmount - liquidatorReward;\n        uint256 playerRewardTotal = 0;\n\n        // 计算有多少玩家可以分配奖励（不包括庄家）\n        uint8 eligiblePlayerCount = 0;\n        for(uint8 i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid() && player.addr != bankerAddr){\n                eligiblePlayerCount++;\n            }\n        }\n\n        // 创建临时数组存储需要支付的地址和金额\n        address[] memory paymentAddresses = new address[](eligiblePlayerCount);\n        uint256[] memory paymentAmounts = new uint256[](eligiblePlayerCount);\n        uint256 paymentCount = 0;\n\n        // 如果没有其他玩家，清算人获得全部奖励\n        if (eligiblePlayerCount == 0) {\n            liquidatorReward = bankerStakeAmount;\n            remainingBankerBet = 0;\n        } else {\n            // 计算每个玩家的奖励\n            uint256 rewardPerPlayer = remainingBankerBet / eligiblePlayerCount;\n\n            // 计算每个玩家应得的金额\n            for (uint i = 0; i < players.length; i++) {\n                BBPlayer storage player = players[i];\n                if(player.isValid() && player.addr != bankerAddr){\n                    uint256 totalPayment = 0;\n\n                    // 计算玩家应得的总金额（押金 + 奖励）\n                    totalPayment += player.totalBet;\n\n                    // 添加奖励金额\n                    totalPayment += rewardPerPlayer;\n\n                    // 记录需要支付的金额\n                    if (totalPayment > 0) {\n                        paymentAddresses[paymentCount] = player.addr;\n                        paymentAmounts[paymentCount] = totalPayment;\n                        paymentCount++;\n                    }\n\n                    playerRewardTotal += rewardPerPlayer;\n                }\n\n                \n            }\n        }\n\n        // 处理可能的舍入误差\n        uint256 actualDistributed = playerRewardTotal + liquidatorReward;\n        if (actualDistributed < bankerStakeAmount) {\n            liquidatorReward += (bankerStakeAmount - actualDistributed);\n        }\n\n        // 重置玩家状态\n        for (uint i = 0; i < players.length; i++) {\n            if(players[i].isValid()){\n                players[i].playerReset();\n            }\n        }\n\n        playerCount = 0;\n        playerReadyCount = 0;\n        playerContinuedCount = 0;\n        totalPrizePool = 0;\n        gameLiquidatedCount++;\n\n        setState(GameState.LIQUIDATED);\n\n        // 所有状态更新完成后，进行转账操作\n        // 然后进行其他转账\n        for (uint i = 0; i < paymentCount; i++) {\n            (bool otherSuccess, ) = payable(paymentAddresses[i]).call{value: paymentAmounts[i]}(\"\");\n            require(otherSuccess, \"transfer to players failed\");\n        }\n\n        // 支付清算人奖励\n        (bool liquidatorSuccess, ) = payable(msg.sender).call{value: liquidatorReward}(\"\");\n        require(liquidatorSuccess, \"transfer to liquidator failed\");\n\n        emit GameTableChanged(address(this));\n    }\n\n\n    /**\n     * @dev 设置游戏状态\n     */\n    function setState(GameState _state) internal {\n        state = _state;\n\n        // 如果进入下注阶段，为所有玩家设置操作截止时间\n        if (_state == GameState.FIRST_BETTING || _state == GameState.SECOND_BETTING) {\n            currentRoundDeadline = block.timestamp + playerTimeout;\n        }\n\n        _updateLastActivity(); // 更新最后活动时间\n\n        emit GameTableChanged(address(this));\n    }\n\n    // 获取所有玩家数据\n    function getAllPlayerData() external view returns (BBPlayer[] memory) {\n        BBPlayer[] memory playerData = new BBPlayer[](playerCount);\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            if(players[i].isValid()){\n                playerData[index] = players[i];\n                playerData[index].cardType = BBCardUtils.calculateCardType(players[i].cards);\n                index++;\n            }\n        }\n\n        return playerData;\n    }\n\n\n    // 获取单个玩家数据\n    function getPlayerData(address playerAddr) external view returns (BBPlayer memory) {\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        BBPlayer memory playerData = player;\n        playerData.cardType = BBCardUtils.calculateCardType(player.cards);\n        return playerData;\n    }\n\n\n    function getTableInfo() external view returns (GameTableView memory) {\n        IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n        (bool canNext, string memory nextTitle, string memory nextReason) = canMoveToNextStep();\n        // 创建一个空的 RewardPoolInfo 结构体\n        RewardPoolInfo memory emptyRewardPoolInfo;\n        if (rewardPoolId != 0) {\n            emptyRewardPoolInfo = rewardPool.getRewardPoolInfo(bankerAddr, rewardPoolId);\n        }\n\n        return GameTableView({\n            // balance: address(this).balance / 1 ether,\n            active: active,\n            gameRound: gameRound,\n            gameLiquidatedCount: gameLiquidatedCount,\n            tableAddr: address(this),\n            tableId: tableId,\n            tableName: tableName,\n            bankerAddr: bankerAddr,\n            betAmount: betAmount,\n            bankerFeePercent: bankerFeePercent,\n            totalPrizePool: totalPrizePool,\n            playerCount: playerCount,\n            maxPlayers: maxPlayers,\n            creationTimestamp: creationTimestamp,\n            state: state,\n            liquidatorFeePercent: liquidatorFeePercent,\n            playerContinuedCount: playerContinuedCount,\n            playerReadyCount: playerReadyCount,\n            playerAddresses: getPlayerAddresses(),\n            currentRoundDeadline: currentRoundDeadline,\n            playerTimeout: playerTimeout,\n            tableInactiveTimeout: tableInactiveTimeout,\n            lastActivityTimestamp: lastActivityTimestamp,\n            rewardPoolId: rewardPoolId,\n            rewardPoolInfo: emptyRewardPoolInfo, // 奖励池信息，如果没有奖励池，则返回空结构体\n            implementationVersion: implementationVersion,\n            firstBetX: firstBetX,\n            secondBetX: secondBetX,\n            bankerStakeAmount: bankerStakeAmount,\n            canNext: canNext,\n            nextTitle: nextTitle,\n            nextReason: nextReason,\n            rewardAddr: rewardAddr,\n            rewardAmount: rewardAmount,\n            chatGroupId: chatGroupId\n        });\n    }\n\n    function getTableInfoShort() external view returns (GameTableInfoShort memory) {\n        IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n\n        // 创建一个空的 RewardPoolInfo 结构体\n        RewardPoolInfo memory emptyRewardPoolInfo;\n        if (rewardPoolId != 0) {\n            emptyRewardPoolInfo = rewardPool.getRewardPoolInfo(bankerAddr, rewardPoolId);\n        }\n\n        return GameTableInfoShort({\n            active: active,\n            gameRound: gameRound,\n            gameLiquidatedCount: gameLiquidatedCount,\n            tableAddr: address(this),\n            tableId: tableId,\n            tableName: tableName,\n            bankerAddr: bankerAddr,\n            betAmount: betAmount,\n            bankerFeePercent: bankerFeePercent,\n            playerCount: playerCount,\n            maxPlayers: maxPlayers,\n            state: state,\n            lastActivityTimestamp: lastActivityTimestamp,\n            rewardPoolId: rewardPoolId,\n            rewardPoolInfo: emptyRewardPoolInfo // 奖励池信息，如果没有奖励池，则返回空结构体\n        });\n    }\n\n    function isPlayer(address playerAddr) external view returns (bool) {\n        _getPlayer(playerAddr);\n        return true;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/BBInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\nimport \"./BBStructs.sol\";\r\n\r\ninterface IGameTableFactory {\r\n    function createGameTable(\r\n        uint256 tableId,\r\n        string memory tableName,\r\n        address bankerAddr,\r\n        uint256 betAmount,\r\n        uint8 maxPlayers,\r\n        address gameMainAddr,\r\n        uint8 bankerFeePercent,\r\n        uint8 firstRaise,\r\n        uint8 secondRaise\r\n    ) external returns (address);\r\n}\r\n\r\ninterface IGameTableImplementation {\r\n    function bankerAddr() external view returns (address);\r\n    function getTableInfo() external view returns (GameTableView memory);\r\n    function getTableInfoShort() external view returns (GameTableInfoShort memory);\r\n    function lastActivityTimestamp() external view returns (uint256);\r\n    function state() external view returns (GameState);\r\n    function rewardPoolId() external view returns (uint256);\r\n    function initialize(\r\n        uint256 _tableId,\r\n        string memory _tableName,\r\n        address _bankerAddr,\r\n        uint256 _betAmount,\r\n        uint8 _maxPlayers,\r\n        address _gameMainAddr,\r\n        uint8 _bankerFeePercent,\r\n        uint8 _firstRaise,\r\n        uint8 _secondRaise,\r\n        uint256 _implementationVersion\r\n    ) external;\r\n}\r\n\r\ninterface IGameMain {\r\n    function isValidGameTable(address) external view returns (bool);\r\n    function liquidatorFeePercent() external view returns (uint256);\r\n    function playerTimeout() external view returns (uint256);\r\n    function tableInactiveTimeout() external view returns (uint256);\r\n    function rewardPoolAddress() external view returns (address);\r\n    function roomCardAddress() external view returns (address);\r\n    function roomLevelAddress() external view returns (address);\r\n    function getGameConfig() external view returns (GameConfig memory);\r\n    function rewardPoolIsInUse(address, uint256) external view returns (bool);\r\n}\r\n\r\ninterface IRewardPool{\r\n    function tryDistributeReward(uint256 _poolId, address[] calldata _players, uint256 finalSeed) external  returns (address, uint256);\r\n    function isBankerPool(address, uint256) external view returns (bool);\r\n    function getRewardPoolInfo(address, uint256) external view returns (RewardPoolInfo memory);\r\n}\r\n\r\ninterface IRoomCardNFT{\r\n    function validateParams(uint256, uint8) external view returns (bool);\r\n    function hasNft(address) external view returns (bool);\r\n    function consume(address, uint256) external;\r\n}"
    },
    "contracts/BBPlayer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\n\r\nstruct BBPlayer {\r\n    address addr;\r\n    PlayerState state;\r\n\r\n    uint256 totalBet;\r\n\r\n    bool hasActedThisRound;   // 本轮是否已操作\r\n    bool isWinner;   // 是否为赢家\r\n\r\n    uint8[5] cards;\r\n    CardType cardType;\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\nlibrary BBPlayerLib {\r\n    /**\r\n     * @dev 玩家准备\r\n     */\r\n    function playerReady(BBPlayer storage self) internal {\r\n        self.state = PlayerState.READY;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家取消准备\r\n     */\r\n    function playerUnready(BBPlayer storage self) internal {\r\n        self.state = PlayerState.JOINED;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家加入\r\n     */\r\n    function playerJoin(BBPlayer storage self) internal {\r\n        self.state = PlayerState.JOINED;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家弃牌\r\n     */\r\n    function playerFold(BBPlayer storage self) internal {\r\n        self.state = PlayerState.FOLDED;\r\n        self.hasActedThisRound = true;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家继续游戏\r\n     */\r\n    function playerContinue(BBPlayer storage self, uint256 additionalBet) internal {\r\n        self.totalBet += additionalBet;\r\n        self.state = PlayerState.ACTIVE;\r\n        self.hasActedThisRound = true;\r\n    }\r\n\r\n    /**\r\n     * @dev 是否有效\r\n     */\r\n    function isValid(BBPlayer storage self) internal view returns (bool) {\r\n        return self.addr != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev 重置玩家数据\r\n     */\r\n    function playerReset(BBPlayer storage self) internal {\r\n        self.state = PlayerState.JOINED;\r\n        self.hasActedThisRound = false;\r\n        self.totalBet = 0;\r\n        self.isWinner = false;\r\n        self.cards = [0, 0, 0, 0, 0];\r\n        self.cardType = CardType.NONE;\r\n    }\r\n}\r\n"
    },
    "contracts/BBRewardPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"./BBTypes.sol\";\r\nimport \"./BBStructs.sol\";\r\nimport \"./BBInterfaces.sol\";\r\n\r\n/**\r\n * @title BBRewardPool\r\n * @dev 牛牛游戏奖励池合约，允许庄家创建奖励池，在游戏结束时随机奖励玩家\r\n */\r\ncontract BBRewardPool is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    ReentrancyGuardUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    \r\n\r\n    // 状态变量\r\n    uint256 private nextPoolId;                           // 下一个奖励池ID\r\n    mapping(address => RewardPoolInfo[]) private bankerPools;      // 庄家拥有的奖励池\r\n\r\n    // 游戏主合约地址\r\n    address public gameMainAddr;\r\n\r\n    // 最大概率值（100 = 100%）\r\n    uint8 private constant MAX_PROBABILITY = 100;\r\n\r\n    // 预留 50 个 slot 给将来新增变量用，防止存储冲突\r\n    uint256[50] private __gap;\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @dev 初始化函数，替代构造函数\r\n     * @param _gameMainAddr 游戏主合约地址\r\n     */\r\n    function initialize(address _gameMainAddr) public initializer {\r\n        __Ownable_init(msg.sender);\r\n        __ReentrancyGuard_init();\r\n        __UUPSUpgradeable_init();\r\n\r\n        require(_gameMainAddr != address(0), \"Invalid game main address\");\r\n        gameMainAddr = _gameMainAddr;\r\n        nextPoolId = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev 创建新的奖励池\r\n     * @param name 奖励池名称\r\n     * @param _totalReward 总奖励金额\r\n     * @param _rewardPerGame 每局游戏奖励金额\r\n     * @param _winProbability 中奖概率（以百分之一为单位，例如10表示10%的概率）\r\n     */\r\n    function createRewardPool(string calldata name, uint256 _totalReward, uint256 _rewardPerGame, uint256 _winProbability) external payable nonReentrant {\r\n        // 验证参数\r\n        require(_rewardPerGame > 0 && _totalReward > 0, \"Invalid reward amount\");\r\n        require(_winProbability > 0 && _winProbability <= MAX_PROBABILITY, \"Invalid win probability\");\r\n        require(msg.value == _totalReward, \"Insufficient funds\");\r\n\r\n        // 创建奖励池\r\n        RewardPoolInfo memory pool;\r\n        pool.name = name;\r\n        pool.poolId = nextPoolId++;\r\n        pool.banker = msg.sender;\r\n        pool.totalAmount = _totalReward;\r\n        pool.rewardPerGame = _rewardPerGame;\r\n        pool.winProbability = _winProbability;\r\n        pool.remainingAmount = _totalReward;\r\n        pool.__gap = [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)];\r\n\r\n        // 添加到庄家的奖励池列表\r\n        bankerPools[msg.sender].push(pool);\r\n\r\n        emit RewardPoolCreated(pool.poolId, msg.sender, msg.value, _rewardPerGame, _winProbability);\r\n    }\r\n\r\n    //验证是否是这个庄家的奖励池\r\n    function isBankerPool(address _banker, uint256 _poolId) external view returns (bool) {\r\n        RewardPoolInfo[] memory pools = bankerPools[_banker];\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            if (pools[i].poolId == _poolId) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev 庄家删除奖励池并取回剩余资金\r\n     * @param _poolId 要删除的奖励池ID\r\n     */\r\n    function removeRewardPool(uint256 _poolId) external nonReentrant {\r\n        RewardPoolInfo[] storage pools = bankerPools[msg.sender];\r\n        require(pools.length > 0, \"Reward pool not active\");\r\n        \r\n        // 查找并验证奖励池\r\n        uint256 poolIndex = type(uint256).max;\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            if (pools[i].poolId == _poolId) {\r\n                poolIndex = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        require(poolIndex != type(uint256).max, \"Reward pool not active\");\r\n\r\n        if(IGameMain(gameMainAddr).rewardPoolIsInUse(msg.sender, _poolId)){\r\n            require(false, \"Reward pool in use\");\r\n        }\r\n        \r\n        RewardPoolInfo storage pool = pools[poolIndex];\r\n        uint256 remainingAmount = pool.remainingAmount;\r\n\r\n        // 从数组中移除奖励池（通过将最后一个元素移到要删除的位置）\r\n        if (poolIndex != pools.length - 1) {\r\n            pools[poolIndex] = pools[pools.length - 1];\r\n        }\r\n        pools.pop();\r\n\r\n        if(remainingAmount > 0){\r\n            // 转账剩余资金给庄家\r\n            (bool success, ) = payable(msg.sender).call{value: remainingAmount}(\"\");\r\n            require(success, \"Transfer failed\");\r\n        }\r\n        \r\n\r\n        emit RewardPoolRemoved(_poolId, msg.sender, remainingAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev 游戏结束时尝试分配奖励\r\n     * @param _poolId 游戏桌地址\r\n     * @param _players 参与游戏的玩家地址数组\r\n     * @param finalSeed 最终种子\r\n     * @return 是否分配了奖励\r\n     */\r\n    function tryDistributeReward(uint256 _poolId, address[] calldata _players, uint256 finalSeed) external nonReentrant returns (address, uint256) {\r\n        address tableAddr = msg.sender;\r\n        address bankerAddr = IGameTableImplementation(tableAddr).bankerAddr();\r\n        require(bankerAddr != address(0), \"invalid banker address\");\r\n\r\n        RewardPoolInfo storage pool = bankerPools[bankerAddr][_poolId];\r\n        if (pool.poolId == 0) return (address(0), 0);\r\n\r\n        // 验证有足够的资金\r\n        if (pool.remainingAmount < pool.rewardPerGame) return (address(0), 0);\r\n\r\n        // 验证有玩家参与\r\n        if (_players.length == 0) return (address(0), 0);\r\n\r\n        // 生成随机数决定是否发放奖励\r\n        uint256 randomValue = _generateRandomNumber(finalSeed, _poolId, tableAddr) % MAX_PROBABILITY;\r\n\r\n        // 如果随机数小于中奖概率，则发放奖励\r\n        if (randomValue < pool.winProbability) {\r\n            // 随机选择一名玩家\r\n            uint256 winnerIndex = _generateRandomNumber(finalSeed, _poolId + 1, tableAddr) % _players.length;\r\n            address winner = _players[winnerIndex];\r\n\r\n            // 更新奖励池余额\r\n            pool.remainingAmount -= pool.rewardPerGame;\r\n\r\n            // 转账奖励给获胜者\r\n            (bool success, ) = payable(winner).call{value: pool.rewardPerGame}(\"\");\r\n            require(success, \"Transfer failed\");\r\n\r\n            emit RewardDistributed(_poolId, tableAddr, winner, pool.rewardPerGame);\r\n            return (winner, pool.rewardPerGame);\r\n        }\r\n\r\n        return (address(0), 0);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev 获取指定地址的所有奖励池\r\n     * @param _banker 庄家地址\r\n     * @return 奖励池信息数组\r\n     */\r\n    function getBankerPools(address _banker) external view returns (RewardPoolInfo[] memory) {\r\n        return bankerPools[_banker];\r\n    }\r\n\r\n    /**\r\n     * @dev 获取指定庄家的指定奖励池信息\r\n     * @param _banker 庄家地址\r\n     * @param _poolId 奖励池ID\r\n     * @return 奖励池信息\r\n     */\r\n    function getRewardPoolInfo(address _banker, uint256 _poolId) external view returns (RewardPoolInfo memory) {\r\n        RewardPoolInfo[] memory pools = bankerPools[_banker];\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            if (pools[i].poolId == _poolId) {\r\n                return pools[i];\r\n            }\r\n        }\r\n        return RewardPoolInfo(0, \"\", address(0), 0, 0, 0, 0, [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)]);\r\n    }\r\n\r\n    /**\r\n     * @dev 更新奖励池的剩余金额（内部函数）\r\n     * @param _banker 庄家地址\r\n     * @param _poolId 奖励池ID\r\n     * @param _amount 要减少的金额\r\n     */\r\n    function _updateRewardPoolAmount(address _banker, uint256 _poolId, uint256 _amount) internal {\r\n        RewardPoolInfo[] storage pools = bankerPools[_banker];\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            if (pools[i].poolId == _poolId) {\r\n                require(pools[i].remainingAmount >= _amount, \"Insufficient funds\");\r\n                pools[i].remainingAmount -= _amount;\r\n                return;\r\n            }\r\n        }\r\n        require(false, \"Reward pool not active\");\r\n    }\r\n\r\n    /**\r\n     * @dev 生成随机数（内部函数）\r\n     * @param _seed1 种子\r\n     * @param _seed2 种子\r\n     * @param _seed3 种子\r\n     * @return 伪随机数\r\n     */\r\n    function _generateRandomNumber(uint256 _seed1, uint256 _seed2, address _seed3) internal view returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(\r\n            _seed1,\r\n            _seed2,\r\n            _seed3,\r\n            block.timestamp,\r\n            block.difficulty,\r\n            blockhash(block.number - 1)\r\n        )));\r\n    }\r\n\r\n    /**\r\n     * @dev 设置游戏主合约地址\r\n     * @param _gameMainAddr 新的游戏主合约地址\r\n     */\r\n    function setGameMainAddress(address _gameMainAddr) external onlyOwner {\r\n        require(_gameMainAddr != address(0), \"Invalid game main address\");\r\n        gameMainAddr = _gameMainAddr;\r\n        emit GameMainAddressUpdated(_gameMainAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev 实现UUPS可升级合约所需的授权检查\r\n     * @param newImplementation 新的实现合约地址\r\n     */\r\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n    // 事件定义\r\n    event RewardPoolCreated(uint256 indexed poolId, address indexed banker, uint256 totalAmount, uint256 rewardPerGame, uint256 winProbability);\r\n    event RewardPoolRemoved(uint256 indexed poolId, address indexed banker, uint256 remainingAmount);\r\n    event TableRewardPoolSet(address indexed tableAddr, uint256 indexed poolId, address indexed banker);\r\n    event TableRewardPoolRemoved(address indexed tableAddr, uint256 indexed poolId, address indexed banker);\r\n    event RewardDistributed(uint256 indexed poolId, address indexed tableAddr, address indexed winner, uint256 amount);\r\n    event GameMainAddressUpdated(address indexed gameMainAddr);\r\n\r\n    \r\n}\r\n"
    },
    "contracts/BBRoomCardNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"./BBStructs.sol\";\r\nimport \"./BBInterfaces.sol\";\r\n\r\n/**\r\n * @title BBRoomCard\r\n * @dev Niu Niu game room card NFT contract with dynamic card types\r\n */\r\ncontract BBRoomCardNFT is\r\n    Initializable,\r\n    ERC721Upgradeable,\r\n    ERC721EnumerableUpgradeable,\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    using Strings for uint256;\r\n\r\n    // Room card type structure - combines type and config in one structure\r\n    \r\n\r\n    // Used to generate unique token IDs\r\n    uint256 private _tokenIdCounter;\r\n\r\n    // Used to generate unique card type IDs\r\n    uint256 private _nftTypeIdCounter;\r\n\r\n    // Room card base URI\r\n    string private _baseTokenURI;\r\n\r\n    // Game main contract address\r\n    address public gameMainAddress;\r\n\r\n    // Card types by ID\r\n    mapping(uint256 => RoomCardNftType) public nftTypes;\r\n\r\n    // Card type ID corresponding to each token ID\r\n    mapping(uint256 => uint256) public tokenNftTypes;\r\n\r\n    // Array of all card type IDs\r\n    uint256[] private _allNftTypeIds;\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @dev Initialization function, replaces constructor\r\n     */\r\n    function initialize(\r\n        string memory name,\r\n        string memory symbol,\r\n        string memory baseTokenURI\r\n    ) public initializer {\r\n        __ERC721_init(name, symbol);\r\n        __ERC721Enumerable_init();\r\n        __Ownable_init(msg.sender);\r\n        __UUPSUpgradeable_init();\r\n\r\n        _baseTokenURI = baseTokenURI;\r\n        _tokenIdCounter = 1;\r\n        _nftTypeIdCounter = 1; // Start from 1\r\n    }\r\n\r\n    /**\r\n     * @dev Set the game main contract address\r\n     * @param _gameMainAddress Game main contract address\r\n     */\r\n    function setGameMainAddress(address _gameMainAddress) external onlyOwner {\r\n        require(_gameMainAddress != address(0), \"Invalid game main address\");\r\n        gameMainAddress = _gameMainAddress;\r\n    }\r\n\r\n    modifier onlyGameTable() {\r\n        bool isValidTable = false;\r\n        if (gameMainAddress != address(0)) {\r\n            if(IGameMain(gameMainAddress).isValidGameTable(msg.sender)){\r\n                isValidTable = true;\r\n            }else{\r\n                isValidTable = false;\r\n            }\r\n        }\r\n        require(isValidTable, \"Only game table can call\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new card type\r\n     * @param name Name of the card type\r\n     * @param maxPlayers Maximum number of players allowed\r\n     * @param price Price to purchase this card\r\n     * @param uriSuffix URI suffix for metadata\r\n     * @return The ID of the newly created card type\r\n     */\r\n    function addType(\r\n        string memory name,\r\n        uint8 maxPlayers,\r\n        uint256 price,\r\n        string memory uriSuffix,\r\n        uint256 maxMint,\r\n        string memory rarity\r\n    ) external onlyOwner returns (uint256) {\r\n        require(bytes(name).length > 0, \"Name cannot be empty\");\r\n        require(maxPlayers > 1, \"Max players must be greater than 1\");\r\n        require(price > 0, \"Price must be greater than 0\");\r\n        require(maxMint > 0, \"Max mint must be greater than 0\");\r\n        require(bytes(rarity).length > 0, \"Rarity cannot be empty\");\r\n\r\n        uint256 newNftTypeId = _nftTypeIdCounter;\r\n        _nftTypeIdCounter++;\r\n\r\n        nftTypes[newNftTypeId] = RoomCardNftType({\r\n            id: newNftTypeId,\r\n            name: name,\r\n            maxPlayers: maxPlayers,\r\n            price: price,\r\n            uriSuffix: uriSuffix,\r\n            active: true,\r\n            maxMint: maxMint,\r\n            rarity: rarity,\r\n            minted: 0,\r\n            __gap: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)]\r\n        });\r\n        _allNftTypeIds.push(newNftTypeId);\r\n        emit CardTypeAdded(newNftTypeId, name, maxPlayers, price, uriSuffix, maxMint, rarity);\r\n        return newNftTypeId;\r\n    }\r\n\r\n    /**\r\n     * @dev Update an existing card type\r\n     * @param nftTypeId Card type ID to update\r\n     * @param maxPlayers New maximum number of players\r\n     * @param price New price\r\n     * @param uriSuffix New URI suffix\r\n     */\r\n    function updateType(\r\n        uint256 nftTypeId,\r\n        uint8 maxPlayers,\r\n        uint256 price,\r\n        string memory uriSuffix,\r\n        uint256 maxMint,\r\n        string memory rarity\r\n    ) external onlyOwner {\r\n        require(nftTypes[nftTypeId].id == nftTypeId, \"Card type does not exist\");\r\n        require(maxPlayers > 1, \"Max players must be greater than 1\");\r\n        require(price > 0, \"Price must be greater than 0\");\r\n        require(maxMint > 0, \"Max mint must be greater than 0\");\r\n        require(bytes(rarity).length > 0, \"Rarity cannot be empty\");\r\n        RoomCardNftType storage nftType = nftTypes[nftTypeId];\r\n        nftType.maxPlayers = maxPlayers;\r\n        nftType.price = price;\r\n        nftType.uriSuffix = uriSuffix;\r\n        nftType.maxMint = maxMint;\r\n        nftType.rarity = rarity;\r\n        emit CardTypeUpdated(nftTypeId, maxPlayers, price, uriSuffix, maxMint, rarity);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a card type's active status\r\n     * @param nftTypeId Card type ID\r\n     * @param active New active status\r\n     */\r\n    function setTypeActive(uint256 nftTypeId, bool active) external onlyOwner {\r\n        // Verify card type exists\r\n        require(nftTypes[nftTypeId].id == nftTypeId, \"Card type does not exist\");\r\n\r\n        nftTypes[nftTypeId].active = active;\r\n        emit CardTypeActiveStatusChanged(nftTypeId, active);\r\n    }\r\n\r\n    /**\r\n     * @dev Purchase a room card\r\n     * @param nftTypeId Card type ID\r\n     * @return Returns the minted room card ID\r\n     */\r\n    function buy(uint256 nftTypeId) external payable returns (uint256) {\r\n        RoomCardNftType storage nftType = nftTypes[nftTypeId];\r\n        require(nftType.id == nftTypeId, \"Card type does not exist\");\r\n        require(nftType.active, \"Card type not active\");\r\n        require(msg.value >= nftType.price, \"Insufficient payment\");\r\n        require(nftType.minted < nftType.maxMint, \"Max mint reached for this card type\");\r\n\r\n        nftType.minted += 1;\r\n        uint256 tokenId = _tokenIdCounter;\r\n        _tokenIdCounter++;\r\n        _safeMint(msg.sender, tokenId);\r\n        tokenNftTypes[tokenId] = nftTypeId;\r\n        if (msg.value > nftType.price) {\r\n            uint256 refundAmount = msg.value - nftType.price;\r\n            (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\r\n            require(success, \"Refund failed\");\r\n        }\r\n        emit RoomCardPurchased(msg.sender, tokenId, nftType.price, nftTypeId);\r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev Batch purchase room cards\r\n     * @param nftTypeId Card type ID\r\n     * @param amount Purchase quantity\r\n     * @return Returns an array of minted room card IDs\r\n     */\r\n    function batchBuy(uint256 nftTypeId, uint256 amount) external payable returns (uint256[] memory) {\r\n        RoomCardNftType storage nftType = nftTypes[nftTypeId];\r\n        require(nftType.id == nftTypeId, \"Card type does not exist\");\r\n        require(nftType.active, \"Card type not active\");\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(msg.value >= nftType.price * amount, \"Insufficient payment\");\r\n        require(nftType.minted + amount <= nftType.maxMint, \"Max mint reached for this card type\");\r\n\r\n        uint256[] memory tokenIds = new uint256[](amount);\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            nftType.minted += 1;\r\n            require(nftType.minted <= nftType.maxMint, \"Max mint reached for this card type\");\r\n\r\n            uint256 tokenId = _tokenIdCounter;\r\n            _tokenIdCounter++;\r\n            _safeMint(msg.sender, tokenId);\r\n            tokenIds[i] = tokenId;\r\n            tokenNftTypes[tokenId] = nftTypeId;\r\n        }\r\n        uint256 totalPrice = nftType.price * amount;\r\n        if (msg.value > totalPrice) {\r\n            uint256 refundAmount = msg.value - totalPrice;\r\n            (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\r\n            require(success, \"Refund failed\");\r\n        }\r\n        emit BatchRoomCardPurchased(msg.sender, tokenIds, totalPrice, nftTypeId);\r\n        return tokenIds;\r\n    }\r\n\r\n    /**\r\n     * @dev Consume room card\r\n     * @param owner Owner of the room card\r\n     * @param tokenId Room card ID to be consumed\r\n     */\r\n    function consume(address owner, uint256 tokenId) external onlyGameTable {\r\n        require(_ownerOf(tokenId) == owner, \"Not approved or owner\");\r\n        _burn(tokenId);\r\n\r\n        emit RoomCardConsumed(owner, tokenId);\r\n    }\r\n\r\n    function increaseMaxMint(uint256 nftTypeId, uint256 addAmount) external onlyOwner {\r\n        require(nftTypes[nftTypeId].id == nftTypeId, \"Card type does not exist\");\r\n        require(addAmount > 0, \"Add amount must be greater than 0\");\r\n        nftTypes[nftTypeId].maxMint += addAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set base URI\r\n     * @param baseURI New base URI\r\n     */\r\n    function setBaseURI(string memory baseURI) external onlyOwner {\r\n        _baseTokenURI = baseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Override base URI function\r\n     */\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return _baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Override tokenURI function, returns different URIs based on room card type\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        _requireOwned(tokenId);\r\n\r\n        uint256 nftTypeId = tokenNftTypes[tokenId];\r\n        string memory baseURI = _baseURI();\r\n        string memory suffix = nftTypes[nftTypeId].uriSuffix;\r\n\r\n        return bytes(baseURI).length > 0 ?\r\n            string(abi.encodePacked(baseURI, suffix)) : \"\";\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Withdraw ETH from the contract\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No funds to withdraw\");\r\n\r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n\r\n        emit Withdrawn(owner(), balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a user owns any room cards\r\n     * @param owner User address\r\n     * @return Whether the user owns any room cards\r\n     */\r\n    function hasNft(address owner) external view returns (bool) {\r\n        return balanceOf(owner) > 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev 获取用户拥有的房卡信息\r\n     * @param userAddress 用户地址\r\n     * @return has 是否拥有房卡\r\n     * @return details 房卡详细信息数组\r\n     */\r\n    function getUserNfts(address userAddress) external view returns (bool has, RoomCardNftDetail[] memory details) {\r\n        has = balanceOf(userAddress) > 0;\r\n\r\n        if (has) {\r\n            uint256 balance = balanceOf(userAddress);\r\n            details = new RoomCardNftDetail[](balance);\r\n\r\n            for (uint256 i = 0; i < balance; i++) {\r\n                uint256 tokenId = tokenOfOwnerByIndex(userAddress, i);\r\n                uint256 nftTypeId = tokenNftTypes[tokenId];\r\n                \r\n                details[i] = RoomCardNftDetail({\r\n                    tokenId: tokenId,\r\n                    nftType: nftTypes[nftTypeId]\r\n                });\r\n            }\r\n        } else {\r\n            details = new RoomCardNftDetail[](0);\r\n        }\r\n\r\n        return (has, details);\r\n    }\r\n\r\n    /**\r\n     * @dev Get card type for a specific token\r\n     * @param tokenId Room card ID\r\n     * @return Card type information\r\n     */\r\n    function getType(uint256 tokenId) external view returns (RoomCardNftType memory) {\r\n        _requireOwned(tokenId);\r\n        uint256 nftTypeId = tokenNftTypes[tokenId];\r\n        return nftTypes[nftTypeId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get all card type IDs\r\n     * @return Array of all card type IDs\r\n     */\r\n    function getAllTypeIds() external view returns (uint256[] memory) {\r\n        return _allNftTypeIds;\r\n    }\r\n\r\n    /**\r\n     * @dev Get all active card types\r\n     * @return Arrays of card type IDs and card types\r\n     */\r\n    function getActiveTypes() external view returns (uint256[] memory, RoomCardNftType[] memory) {\r\n        uint256 activeCount = 0;\r\n\r\n        // Count active card types\r\n        for (uint256 i = 0; i < _allNftTypeIds.length; i++) {\r\n            uint256 typeId = _allNftTypeIds[i];\r\n            if (nftTypes[typeId].active) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Create arrays for active card types\r\n        uint256[] memory activeIds = new uint256[](activeCount);\r\n        RoomCardNftType[] memory activeTypes = new RoomCardNftType[](activeCount);\r\n\r\n        // Fill arrays\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < _allNftTypeIds.length; i++) {\r\n            uint256 typeId = _allNftTypeIds[i];\r\n            if (nftTypes[typeId].active) {\r\n                activeIds[index] = typeId;\r\n                activeTypes[index] = nftTypes[typeId];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return (activeIds, activeTypes);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate if room card meets game parameter requirements\r\n     * @param tokenId Room card ID\r\n     * @param maxPlayers Maximum number of players\r\n     * @return Whether requirements are met\r\n     */\r\n    function validateParams(uint256 tokenId, uint8 maxPlayers) external view returns (bool) {\r\n        _requireOwned(tokenId);\r\n        uint256 nftTypeId = tokenNftTypes[tokenId];\r\n        RoomCardNftType memory nftType = nftTypes[nftTypeId];\r\n\r\n        return (maxPlayers <= nftType.maxPlayers);\r\n    }\r\n\r\n    function _increaseBalance(address account, uint128 value) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\r\n        super._increaseBalance(account, value);\r\n    }\r\n\r\n    function _update(\r\n        address to,\r\n        uint256 tokenId,\r\n        address auth\r\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (address) {\r\n        return super._update(to, tokenId, auth);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    // Authorize upgrade\r\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n    /**\r\n     * @dev Function that must be implemented by contracts that need to receive funds\r\n     */\r\n    receive() external payable {}\r\n\r\n    // Event definitions\r\n    event CardTypeAdded(uint256 indexed nftTypeId, string name, uint8 maxPlayers, uint256 price, string uriSuffix, uint256 maxMint, string rarity);\r\n    event CardTypeUpdated(uint256 indexed nftTypeId, uint8 maxPlayers, uint256 price, string uriSuffix, uint256 maxMint, string rarity);\r\n    event CardTypeMaxMintIncreased(uint256 indexed nftTypeId, uint256 newMaxMint);\r\n    event CardTypeActiveStatusChanged(uint256 indexed nftTypeId, bool active);\r\n    event RoomCardPurchased(address indexed buyer, uint256 tokenId, uint256 price, uint256 nftTypeId);\r\n    event BatchRoomCardPurchased(address indexed buyer, uint256[] tokenIds, uint256 totalPrice, uint256 nftTypeId);\r\n    event RoomCardConsumed(address indexed owner, uint256 tokenId);\r\n    event Withdrawn(address indexed to, uint256 amount);\r\n}\r\n"
    },
    "contracts/BBRoomLevelNFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./BBStructs.sol\";\n\n/**\n * @title BBRoomLevel\n * @dev Niu Niu game room level NFT contract that determines how many rooms a player can create\n */\ncontract BBRoomLevelNFT is\n    Initializable,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    OwnableUpgradeable,\n    UUPSUpgradeable\n{\n    using Strings for uint256;\n\n    \n    // Used to generate unique token IDs\n    uint256 private _tokenIdCounter;\n\n    // Used to generate unique level type IDs\n    uint256 private _nftTypeIdCounter;\n\n    // Room level base URI\n    string private _baseTokenURI;\n\n    // Game main contract address\n    address public gameMainAddress;\n\n    // Level types by ID\n    mapping(uint256 => RoomLevelNftType) public nftTypes;\n\n    // Level type ID corresponding to each token ID\n    mapping(uint256 => uint256) public tokenNftTypes;\n\n    // Array of all level type IDs\n    uint256[] private _allNftTypeIds;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initialization function, replaces constructor\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        string memory baseTokenURI\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __ERC721Enumerable_init();\n        __Ownable_init(msg.sender);\n        __UUPSUpgradeable_init();\n\n        _baseTokenURI = baseTokenURI;\n        _tokenIdCounter = 0;\n        _nftTypeIdCounter = 1; // Start from 1\n    }\n\n    /**\n     * @dev Set the game main contract address\n     * @param _gameMainAddress Game main contract address\n     */\n    function setGameMainAddress(address _gameMainAddress) external onlyOwner {\n        require(_gameMainAddress != address(0), \"Invalid game main address\");\n        gameMainAddress = _gameMainAddress;\n    }\n\n    /**\n     * @dev Add a new level type\n     * @param name Name of the level type\n     * @param maxRooms Maximum number of rooms allowed\n     * @param price Price to purchase this level\n     * @param uriSuffix URI suffix for metadata\n     * @return The ID of the newly created level type\n     */\n    function addType(\n        string memory name,\n        uint256 maxRooms,\n        uint256 price,\n        string memory uriSuffix,\n        uint256 maxMint,\n        string memory rarity\n    ) external onlyOwner returns (uint256) {\n        require(bytes(name).length > 0, \"Name cannot be empty\");\n        require(maxRooms > 0, \"Max rooms must be greater than 0\");\n        require(price > 0, \"Price must be greater than 0\");\n        require(maxMint > 0, \"Max mint must be greater than 0\");\n\n        uint256 newNftTypeId = _nftTypeIdCounter;\n        _nftTypeIdCounter++;\n\n        nftTypes[newNftTypeId] = RoomLevelNftType({\n            id: newNftTypeId,\n            name: name,\n            maxRooms: maxRooms,\n            price: price,\n            uriSuffix: uriSuffix,\n            active: true,\n            maxMint: maxMint,\n            minted: 0,\n            rarity: rarity,\n            __gap: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)]\n        });\n\n        _allNftTypeIds.push(newNftTypeId);\n\n        emit LevelTypeAdded(newNftTypeId, name, maxRooms, price, uriSuffix);\n        return newNftTypeId;\n    }\n\n    /**\n     * @dev Update an existing level type\n     * @param nftTypeId Level type ID to update\n     * @param maxRooms New maximum number of rooms\n     * @param price New price\n     * @param uriSuffix New URI suffix\n     */\n    function updateType(\n        uint256 nftTypeId,\n        uint256 maxRooms,\n        uint256 price,\n        string memory uriSuffix,\n        uint256 maxMint,\n        string memory rarity\n    ) external onlyOwner {\n        require(nftTypes[nftTypeId].id == nftTypeId, \"Level type does not exist\");\n        require(maxRooms > 0, \"Max rooms must be greater than 0\");\n        require(price > 0, \"Price must be greater than 0\");\n        require(maxMint > 0, \"Max mint must be greater than 0\");\n\n        RoomLevelNftType storage nftType = nftTypes[nftTypeId];\n        nftType.maxRooms = maxRooms;\n        nftType.price = price;\n        nftType.uriSuffix = uriSuffix;\n        nftType.maxMint = maxMint;\n        nftType.rarity = rarity;\n\n        emit LevelTypeUpdated(nftTypeId, maxRooms, price, uriSuffix);\n    }\n\n    /**\n     * @dev Set a level type's active status\n     * @param nftTypeId Level type ID\n     * @param active New active status\n     */\n    function setTypeActive(uint256 nftTypeId, bool active) external onlyOwner {\n        // Verify level type exists\n        require(nftTypes[nftTypeId].id == nftTypeId, \"Level type does not exist\");\n\n        nftTypes[nftTypeId].active = active;\n        emit LevelTypeActiveStatusChanged(nftTypeId, active);\n    }\n\n    /**\n     * @dev Purchase a room level\n     * @param nftTypeId Level type ID\n     * @return Returns the minted level token ID\n     */\n    function buy(uint256 nftTypeId) external payable returns (uint256) {\n        RoomLevelNftType storage nftType = nftTypes[nftTypeId];\n        require(nftType.id == nftTypeId, \"Level type does not exist\");\n        require(nftType.active, \"Level type not active\");\n        require(msg.value >= nftType.price, \"Insufficient payment\");\n        require(nftType.minted < nftType.maxMint, \"Max mint reached for this level type\");\n\n        nftType.minted += 1;\n        uint256 tokenId = _tokenIdCounter;\n        _tokenIdCounter++;\n        _safeMint(msg.sender, tokenId);\n        tokenNftTypes[tokenId] = nftTypeId;\n        \n        if (msg.value > nftType.price) {\n            uint256 refundAmount = msg.value - nftType.price;\n            (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n            require(success, \"Refund failed\");\n        }\n\n        emit RoomLevelPurchased(msg.sender, tokenId, nftType.price, nftTypeId);\n        return tokenId;\n    }\n\n    /**\n     * @dev Batch purchase room levels\n     * @param nftTypeId Level type ID\n     * @param amount Purchase quantity\n     * @return Returns an array of minted room level IDs\n     */\n    function batchBuy(uint256 nftTypeId, uint256 amount) external payable returns (uint256[] memory) {\n        RoomLevelNftType storage nftType = nftTypes[nftTypeId];\n        require(nftType.id == nftTypeId, \"Level type does not exist\");\n        require(nftType.active, \"Level type not active\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(msg.value >= nftType.price * amount, \"Insufficient payment\");\n        require(nftType.minted + amount <= nftType.maxMint, \"Max mint reached for this level type\");\n\n        uint256[] memory tokenIds = new uint256[](amount);\n        for (uint256 i = 0; i < amount; i++) {\n            nftType.minted += 1;\n            require(nftType.minted <= nftType.maxMint, \"Max mint reached for this level type\");\n\n            uint256 tokenId = _tokenIdCounter;\n            _tokenIdCounter++;\n            _safeMint(msg.sender, tokenId);\n            tokenIds[i] = tokenId;\n            tokenNftTypes[tokenId] = nftTypeId;\n        }\n\n        uint256 totalPrice = nftType.price * amount;\n        if (msg.value > totalPrice) {\n            uint256 refundAmount = msg.value - totalPrice;\n            (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n            require(success, \"Refund failed\");\n        }\n\n        emit BatchRoomLevelPurchased(msg.sender, tokenIds, totalPrice, nftTypeId);\n        return tokenIds;\n    }\n\n    function increaseMaxMint(uint256 nftTypeId, uint256 addAmount) external onlyOwner {\n        require(nftTypes[nftTypeId].id == nftTypeId, \"Level type does not exist\");\n        require(addAmount > 0, \"Add amount must be greater than 0\");\n        nftTypes[nftTypeId].maxMint += addAmount;\n    }\n\n    /**\n     * @dev Get the maximum number of rooms a user can create\n     * @param user User address\n     * @return Maximum number of rooms the user can create (sum of all level NFTs owned)\n     */\n    function getMaxRooms(address user) external view returns (uint256) {\n        uint256 balance = balanceOf(user);\n\n        // If user has no level tokens, return default value (0 or 1 depending on your requirements)\n        if (balance == 0) {\n            return 0; // Default value, can be changed as needed\n        }\n\n        // Calculate total max rooms from all level tokens owned by the user\n        uint256 totalMaxRooms = 0;\n\n        for (uint256 i = 0; i < balance; i++) {\n            uint256 tokenId = tokenOfOwnerByIndex(user, i);\n            uint256 nftTypeId = tokenNftTypes[tokenId];\n\n            // Add this token's max rooms to the total\n            totalMaxRooms += nftTypes[nftTypeId].maxRooms;\n        }\n\n        return totalMaxRooms;\n    }\n\n    /**\n     * @dev Set base URI\n     * @param baseURI New base URI\n     */\n    function setBaseURI(string memory baseURI) external onlyOwner {\n        _baseTokenURI = baseURI;\n    }\n\n    /**\n     * @dev Override base URI function\n     */\n    function _baseURI() internal view override returns (string memory) {\n        return _baseTokenURI;\n    }\n\n    /**\n     * @dev Override tokenURI function, returns different URIs based on level type\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireOwned(tokenId);\n\n        uint256 nftTypeId = tokenNftTypes[tokenId];\n        string memory baseURI = _baseURI();\n        string memory suffix = nftTypes[nftTypeId].uriSuffix;\n\n        return bytes(baseURI).length > 0 ?\n            string(abi.encodePacked(baseURI, suffix, \"/\", tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Withdraw ETH from the contract\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\n        require(success, \"Withdrawal failed\");\n\n        emit Withdrawn(owner(), balance);\n    }\n\n    /**\n     * @dev Check if a user has a room level\n     * @param user User address\n     * @return Whether the user has a room level\n     */\n    function hasNft(address user) external view returns (bool) {\n        return balanceOf(user) > 0;\n    }\n\n    /**\n     * @dev Get user's room level information\n     * @param userAddress User address to check\n     * @return has Whether the user has any room level\n     * @return details Array of level details\n     * @return totalMaxRooms Total maximum rooms allowed\n     */\n    function getUserNfts(address userAddress) external view returns (\n        bool has,\n        RoomLevelNftDetail[] memory details,\n        uint256 totalMaxRooms\n    ) {\n        has = balanceOf(userAddress) > 0;\n\n        if (has) {\n            uint256 balance = balanceOf(userAddress);\n            details = new RoomLevelNftDetail[](balance);\n\n            totalMaxRooms = 0;\n            for (uint256 i = 0; i < balance; i++) {\n                uint256 tokenId = tokenOfOwnerByIndex(userAddress, i);\n                uint256 nftTypeId = tokenNftTypes[tokenId];\n                \n                details[i] = RoomLevelNftDetail({\n                    tokenId: tokenId,\n                    nftType: nftTypes[nftTypeId]\n                });\n                \n                totalMaxRooms += nftTypes[nftTypeId].maxRooms;\n            }\n        } else {\n            details = new RoomLevelNftDetail[](0);\n            totalMaxRooms = 0;\n        }\n\n        return (has, details, totalMaxRooms);\n    }\n\n    /**\n     * @dev Get level type for a specific token\n     * @param tokenId Level token ID\n     * @return Level type information\n     */\n    function getType(uint256 tokenId) external view returns (RoomLevelNftType memory) {\n        _requireOwned(tokenId);\n        uint256 nftTypeId = tokenNftTypes[tokenId];\n        return nftTypes[nftTypeId];\n    }\n\n    /**\n     * @dev Get all level type IDs\n     * @return Array of all level type IDs\n     */\n    function getAllTypeIds() external view returns (uint256[] memory) {\n        return _allNftTypeIds;\n    }\n\n    /**\n     * @dev Get all active level types\n     * @return Arrays of level type IDs and level types\n     */\n    function getActiveTypes() external view returns (uint256[] memory, RoomLevelNftType[] memory) {\n        uint256 activeCount = 0;\n\n        // Count active level types\n        for (uint256 i = 0; i < _allNftTypeIds.length; i++) {\n            uint256 typeId = _allNftTypeIds[i];\n            if (nftTypes[typeId].active) {\n                activeCount++;\n            }\n        }\n\n        // Create arrays for active level types\n        uint256[] memory activeIds = new uint256[](activeCount);\n        RoomLevelNftType[] memory activeTypes = new RoomLevelNftType[](activeCount);\n\n        // Fill arrays\n        uint256 index = 0;\n        for (uint256 i = 0; i < _allNftTypeIds.length; i++) {\n            uint256 typeId = _allNftTypeIds[i];\n            if (nftTypes[typeId].active) {\n                activeIds[index] = typeId;\n                activeTypes[index] = nftTypes[typeId];\n                index++;\n            }\n        }\n\n        return (activeIds, activeTypes);\n    }\n\n    function _increaseBalance(address account, uint128 value) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._increaseBalance(account, value);\n    }\n\n    /**\n     * @dev Override _update to prevent transfers\n     */\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // If this is a transfer (not a mint or burn), prevent it\n        if (from != address(0) && to != address(0)) {\n            // Only allow transfers initiated by the contract itself\n            require(auth == address(this), \"BBRoomLevel: NFT is not transferable\");\n        }\n\n        return super._update(to, tokenId, auth);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    // Authorize upgrade\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /**\n     * @dev Function that must be implemented by contracts that need to receive funds\n     */\n    receive() external payable {}\n\n    // Event definitions\n    event LevelTypeAdded(uint256 indexed nftTypeId, string name, uint256 maxRooms, uint256 price, string uriSuffix);\n    event LevelTypeUpdated(uint256 indexed nftTypeId, uint256 maxRooms, uint256 price, string uriSuffix);\n    event LevelTypeActiveStatusChanged(uint256 indexed nftTypeId, bool active);\n    event RoomLevelPurchased(address indexed buyer, uint256 tokenId, uint256 price, uint256 nftTypeId);\n    event BatchRoomLevelPurchased(address indexed buyer, uint256[] tokenIds, uint256 totalPrice, uint256 nftTypeId);\n    event RoomLevelUpgraded(address indexed owner, uint256 tokenId, uint256 oldLevelTypeId, uint256 newLevelTypeId, uint256 pricePaid);\n    event Withdrawn(address indexed to, uint256 amount);\n}\n\n\n\n"
    },
    "contracts/BBStructs.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\nimport \"./BBPlayer.sol\";\r\n\r\n/**\r\n * @title BBStructs\r\n * @dev 牛牛游戏结构体定义\r\n */\r\n\r\nstruct GameConfig {\r\n    uint8 maxRoomCount;\r\n    uint8 maxPlayers;\r\n    uint8 maxBankerFeePercent;\r\n    uint256 playerTimeout;\r\n    uint256 tableInactiveTimeout;\r\n    uint8 liquidatorFeePercent;\r\n    address gameMainAddress;\r\n    address rewardPoolAddress;\r\n    address roomCardAddress;\r\n    address roomLevelAddress;\r\n    address gameTableFactoryAddress;\r\n}\r\n\r\n// 奖励池结构\r\nstruct RewardPoolInfo {\r\n    uint256 poolId;           // 奖励池ID\r\n    string name;              // 奖励池名称\r\n    address banker;           // 创建者（庄家）地址\r\n    uint256 totalAmount;      // 总奖池金额\r\n    uint256 rewardPerGame;    // 每局游戏奖励金额\r\n    uint256 winProbability;   // 中奖概率（以百分之一为单位）\r\n    uint256 remainingAmount;  // 剩余奖池金额\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\nstruct RoomCardNftType {\r\n    uint256 id;              // Unique identifier for the card type\r\n    string name;             // Name of the card type (e.g., \"SILVER\", \"GOLD\", \"DIAMOND\")\r\n    uint8 maxPlayers;        // Maximum number of players allowed\r\n    uint256 price;           // Price to purchase this card\r\n    string uriSuffix;        // URI suffix for metadata\r\n    bool active;             // Whether this card type is active\r\n    uint256 maxMint;         // Maximum mint amount for this card type\r\n    string rarity;           // Rarity of the card type\r\n    uint256 minted;          // 已mint数量\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\n// 定义卡片详细信息结构体\r\nstruct RoomCardNftDetail {\r\n    uint256 tokenId;       // 卡片的token ID\r\n    RoomCardNftType nftType;     // 继承CardType的所有属性\r\n}\r\n\r\n// Room level structure\r\nstruct RoomLevelNftType {\r\n    uint256 id;              // Unique identifier for the level type\r\n    string name;             // Name of the level (e.g., \"BRONZE\", \"SILVER\", \"GOLD\")\r\n    uint256 maxRooms;        // Maximum number of rooms allowed with this level\r\n    uint256 price;           // Price to purchase this level\r\n    string uriSuffix;        // URI suffix for metadata\r\n    bool active;             // Whether this level type is active\r\n    uint256 maxMint;         // Maximum mint amount for this level type\r\n    uint256 minted;          // Already minted amount for this level type\r\n    string rarity;           // Rarity of this level type\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\n// Level details structure for returning comprehensive information\r\nstruct RoomLevelNftDetail {\r\n    uint256 tokenId;         // Level token ID\r\n    RoomLevelNftType nftType;     // Level type information\r\n}\r\n\r\n// 添加一个新的结构体用于返回游戏桌信息\r\nstruct GameTableView {\r\n    bool active;\r\n    uint256 gameRound;\r\n    uint256 gameLiquidatedCount;\r\n    address tableAddr; // 游戏桌合约地址\r\n    uint256 tableId;\r\n    string tableName;\r\n    address bankerAddr;\r\n    uint256 betAmount;\r\n    uint8 bankerFeePercent;\r\n    uint256 totalPrizePool;\r\n    uint8 playerCount;\r\n    uint8 maxPlayers;\r\n    uint256 creationTimestamp;\r\n    GameState state;\r\n    uint8 liquidatorFeePercent;\r\n    uint8 playerContinuedCount;\r\n    uint8 playerReadyCount;\r\n    address[] playerAddresses;\r\n    uint256 currentRoundDeadline;\r\n    uint256 playerTimeout;\r\n    uint256 tableInactiveTimeout;\r\n    uint256 lastActivityTimestamp;\r\n    uint256 rewardPoolId;\r\n    RewardPoolInfo rewardPoolInfo; // 奖励池信息，如果没有奖励池，则返回空结构体\r\n    uint256 implementationVersion; // 添加实现版本号\r\n    uint8 firstBetX;\r\n    uint8 secondBetX;\r\n    uint256 bankerStakeAmount;\r\n    bool canNext;\r\n    string nextTitle;\r\n    string nextReason;\r\n    address rewardAddr;\r\n    uint256 rewardAmount;\r\n    string chatGroupId;\r\n}\r\n\r\n// 添加一个新的结构体用于返回游戏桌信息\r\nstruct GameTableInfoShort {\r\n    bool active;\r\n    uint256 gameRound;\r\n    uint256 gameLiquidatedCount;\r\n    address tableAddr; // 游戏桌合约地址\r\n    uint256 tableId;\r\n    string tableName;\r\n    address bankerAddr;\r\n    uint256 betAmount;\r\n    uint8 bankerFeePercent;\r\n    uint8 playerCount;\r\n    uint8 maxPlayers;\r\n    GameState state;\r\n    uint256 lastActivityTimestamp;\r\n    uint256 rewardPoolId;\r\n    RewardPoolInfo rewardPoolInfo; // 奖励池信息，如果没有奖励池，则返回空结构体\r\n}"
    },
    "contracts/BBTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\n/**\r\n * @title BBTypes\r\n * @dev 牛牛游戏类型定义\r\n */\r\n\r\n// 游戏状态\r\nenum GameState {\r\n    NONE,\r\n    WAITING,\r\n    FIRST_BETTING,\r\n    SECOND_BETTING,\r\n    ENDED,\r\n    SETTLED,\r\n    LIQUIDATED\r\n}\r\n\r\n// 玩家状态\r\nenum PlayerState {\r\n    NONE,\r\n    JOINED,\r\n    READY,\r\n    ACTIVE,       // 当前参与游戏中，未弃牌\r\n    FOLDED        // 弃牌\r\n}\r\n\r\n// 牌型\r\nenum CardType {\r\n    NONE,\r\n    NO_BULL,\r\n    BULL_1,\r\n    BULL_2,\r\n    BULL_3,\r\n    BULL_4,\r\n    BULL_5,\r\n    BULL_6,\r\n    BULL_7,\r\n    BULL_8,\r\n    BULL_9,\r\n    BULL_BULL,\r\n    FIVE_BOMB,\r\n    FIVE_SMALL,\r\n    FIVE_FLOWERS\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "viaIR": true,
    "evmVersion": "london",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}