{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/BBCardDealer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBCardUtils.sol\";\r\nimport \"./BBTypes.sol\";\r\n\r\n/**\r\n * @title BBCardDealer\r\n * @dev 牌局管理工具，负责发牌和记录已发的牌\r\n * @notice 进行了以下优化：\r\n *  - 改进随机性处理\r\n *  - 优化避免重复牌的算法\r\n *  - 明确使用标准52张扑克牌(无大小王)\r\n *  - 增加边界检查\r\n *  - 减少 gas 消耗\r\n *  - 添加事件通知\r\n *  - 完善 NatSpec 文档\r\n */\r\nlibrary BBCardDealer {\r\n    // 牌组常量\r\n    uint8 internal constant TOTAL_CARDS = 52; // 标准52张扑克牌(无大小王)\r\n\r\n    /**\r\n     * @dev 发牌管理器状态\r\n     */\r\n    struct DealerState {\r\n        mapping(uint8 => bool) usedCards; // 已使用的牌\r\n        uint256 lastSeed;      // 上次使用的随机种子\r\n    }\r\n\r\n    /**\r\n     * @dev 初始化发牌状态(使用默认的5张牌)\r\n     * @param self 发牌状态\r\n     * @param newSeed 初始随机种子\r\n     */\r\n    function initialize(DealerState storage self, uint256 newSeed) internal {\r\n        self.lastSeed = uint256(keccak256(abi.encodePacked(\r\n            self.lastSeed,\r\n            block.prevrandao,\r\n            block.timestamp,\r\n            newSeed\r\n        )));\r\n    }\r\n\r\n    /**\r\n     * @dev 重置发牌状态\r\n     * @param self 发牌状态\r\n     */\r\n    function reset(DealerState storage self) internal {\r\n        // Clear all used cards by iterating through 1 to TOTAL_CARDS\r\n        for (uint8 i = 1; i <= TOTAL_CARDS; i++) {\r\n            self.usedCards[i] = false;\r\n        }\r\n\r\n        // 重置随机种子\r\n        self.lastSeed = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev 使用改进的算法生成单张牌，确保不与玩家已有牌重复\r\n     * @param self 发牌状态\r\n     * @param player 玩家地址\r\n     * @return 新生成的牌 (1-52范围内)\r\n     */\r\n    function generateCard(\r\n        DealerState storage self, \r\n        address player,\r\n        uint8 count\r\n    ) internal returns (uint8) {        \r\n        // 生成1-52的牌 (标准52张扑克牌，无大小王)\r\n        uint8 newCard;\r\n        uint8 attempts = 0;\r\n        \r\n        // 使用映射快速检查是否重复，最多尝试25次\r\n        do {\r\n            uint256 hash = uint256(keccak256(abi.encodePacked(self.lastSeed, player, count, attempts)));\r\n            // 确保范围在1-52之间 (% TOTAL_CARDS + 1)\r\n            newCard = uint8((hash % TOTAL_CARDS) + 1);\r\n            attempts++;\r\n            \r\n            // 防止无限循环\r\n            require(attempts <= 25, \"Failed to generate unique card\");\r\n            \r\n        } while (self.usedCards[newCard]);\r\n        \r\n        // 记录该牌已被使用\r\n        self.usedCards[newCard] = true;\r\n\r\n        return newCard;\r\n    }\r\n\r\n    /**\r\n     * @dev 为玩家发指定数量的牌\r\n     * @param self 发牌状态\r\n     * @param player 玩家地址\r\n     * @param count 要发的牌数量\r\n     * @return 新发的牌\r\n     */\r\n    function dealCards(\r\n        DealerState storage self, \r\n        address player, \r\n        uint8 count\r\n    ) internal returns (uint8[] memory) {            \r\n        uint8[] memory newCards = new uint8[](count);\r\n\r\n        for (uint8 i = 0; i < count; i++) {\r\n            // 为每张牌使用不同的种子\r\n            newCards[i] = generateCard(self, player, count);\r\n        }\r\n\r\n        return newCards;\r\n    }\r\n\r\n    /**\r\n     * @dev 根据轮次为多个玩家发牌\r\n     * @param self 发牌状态\r\n     * @param round 当前轮次(1=第一轮发3张, 2=第二轮发1张, 3=第三轮发1张)\r\n     */\r\n    function dealCardsByRoundForPlayer(\r\n        DealerState storage self,\r\n        address player,\r\n        uint8 round\r\n    ) internal returns (uint8[] memory)  {\r\n        require(round >= 1 && round <= 3, \"Invalid round\");\r\n\r\n        // 根据轮次确定发牌数量\r\n        uint8 cardCount = round == 1 ? 3 : 1;\r\n\r\n        // 更新随机种子，加入轮次信息和区块信息增加随机性\r\n        self.lastSeed = uint256(keccak256(abi.encodePacked(\r\n            self.lastSeed, \r\n            player,\r\n            round, \r\n            block.timestamp, \r\n            block.difficulty\r\n        )));\r\n\r\n        return dealCards(self, player, cardCount);\r\n    }\r\n}\r\n"
    },
    "contracts/BBCardUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\n\r\n/**\r\n * @title CardUtils\r\n * @dev 牌型计算和比较的工具库\r\n */\r\nlibrary BBCardUtils {\r\n    /**\r\n     * @dev 合并两轮牌\r\n     */\r\n    function combineCards(uint8[3] memory firstCards, uint8[2] memory secondCards) internal pure returns (uint8[5] memory) {\r\n        uint8[5] memory allCards;\r\n\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            allCards[i] = firstCards[i];\r\n        }\r\n\r\n        for (uint8 i = 0; i < 2; i++) {\r\n            allCards[i + 3] = secondCards[i];\r\n        }\r\n\r\n        return allCards;\r\n    }\r\n\r\n    /**\r\n     * @dev 计算牌型\r\n     */\r\n    function calculateCardType(uint8[5] memory cards) internal pure returns (CardType) {\r\n        // 检查是否有无效牌（0表示无效牌）\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            if (cards[i] == 0) {\r\n                return CardType.NONE;\r\n            }\r\n        }\r\n        \r\n        // 转换牌面值（1-13）和花色（0-3）\r\n        uint8[5] memory values;\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            values[i] = ((cards[i] - 1) % 13) + 1;\r\n        }\r\n\r\n        // 检查特殊牌型\r\n        if (isFiveFlower(values)) {\r\n            return CardType.FIVE_FLOWERS;\r\n        }\r\n        \r\n        if (isFiveBomb(values)) {\r\n            return CardType.FIVE_BOMB;\r\n        }\r\n\r\n        if (isFiveSmall(values)) {\r\n            return CardType.FIVE_SMALL;\r\n        }\r\n\r\n        // 计算牛牛牌型\r\n        return calculateBullType(values);\r\n    }\r\n\r\n    /**\r\n     * @dev 检查是否是五花牛（5张牌都是JQK）\r\n     */\r\n    function isFiveFlower(uint8[5] memory values) internal pure returns (bool) {\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            if (values[i] < 11) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev 检查是否是炸弹牛（4张相同点数）\r\n     */\r\n    function isFiveBomb(uint8[5] memory values) internal pure returns (bool) {\r\n        // 统计每个点数出现的次数\r\n        uint8[14] memory counts;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            counts[values[i]]++;\r\n        }\r\n\r\n        // 检查是否有点数出现4次\r\n        for (uint8 i = 1; i <= 13; i++) {\r\n            if (counts[i] == 4) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev 检查是否是五小牛（5张牌点数和小于等于10）\r\n     */\r\n    function isFiveSmall(uint8[5] memory values) internal pure returns (bool) {\r\n        uint8 sum = 0;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            // J、Q、K的点数都按10计算\r\n            uint8 value = values[i] > 10 ? 10 : values[i];\r\n            sum += value;\r\n        }\r\n\r\n        return sum <= 10;\r\n    }\r\n\r\n    /**\r\n     * @dev 计算有牛牌型\r\n     */\r\n    function calculateBullType(uint8[5] memory values) internal pure returns (CardType) {\r\n        // 转换点数（J、Q、K都按10计算）\r\n        uint8[5] memory points;\r\n        uint8 sum = 0;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            points[i] = values[i] > 10 ? 10 : values[i];\r\n            sum += points[i];\r\n        }\r\n\r\n        // 尝试所有可能的3张牌组合，看是否能凑成10的倍数\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            for (uint8 j = i + 1; j < 4; j++) {\r\n                for (uint8 k = j + 1; k < 5; k++) {\r\n                    uint8 threeSum = points[i] + points[j] + points[k];\r\n\r\n                    if (threeSum % 10 == 0) {\r\n                        // 找到一个有效组合，计算剩余两张牌的点数和\r\n                        uint8 remainingSum = sum - threeSum;\r\n                        uint8 remainder = remainingSum % 10;\r\n\r\n                        if (remainder == 0) {\r\n                            return CardType.BULL_BULL;\r\n                        } else {\r\n                            // 返回对应的牛几，需要加1来对应正确的枚举值\r\n                            return CardType(remainder + 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 没有找到有效组合，返回无牛\r\n        return CardType.NO_BULL;\r\n    }\r\n\r\n    /**\r\n     * @dev 比较两个牌型的大小\r\n     * @return 1 如果cardType1大于cardType2，0 如果相等，-1 如果cardType1小于cardType2\r\n     */\r\n    function compareCardType(CardType cardType1, CardType cardType2) internal pure returns (int8) {\r\n        if (uint8(cardType1) > uint8(cardType2)) {\r\n            return 1;\r\n        } else if (uint8(cardType1) < uint8(cardType2)) {\r\n            return -1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/BBGameTableImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./BBCardUtils.sol\";\nimport \"./BBPlayer.sol\";\nimport \"./BBTypes.sol\";\nimport \"./BBCardDealer.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n// import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./BBInterfaces.sol\";\n\n/**\n * @title BBGameTableImplementation\n * @dev 牛牛游戏桌实现合约，管理单个游戏桌的逻辑\n */\ncontract BBGameTableImplementation is ReentrancyGuard, Ownable {\n    using BBPlayerLib for BBPlayer;\n    using BBCardUtils for uint8[5];\n    using BBCardDealer for BBCardDealer.DealerState;\n\n    // 游戏桌数据\n    bool public active;\n    uint256 public tableId; // 游戏桌ID\n    string public tableName;\n    address public bankerAddr;\n    uint256 public betAmount;  // 固定押注金额\n    uint8 public playerCount;\n    uint8 public maxPlayers;\n    uint256 public creationTimestamp;\n    GameState public state;\n    uint256 public rewardPoolId;\n    uint256 public bankerStakeAmount;  //庄家的押金\n    uint256 public totalIncome; // 总收入\n\n    // 第一、二轮下注金额是第一轮的倍数，默认2\n    uint8 public firstBetX;\n    uint8 public secondBetX;\n\n    uint256 public gameRound; //游戏场次\n    uint256 public gameLiquidatedCount; //被清算的游戏场数\n\n    uint256 public finalSeed; // 最后一次使用的种子\n\n    uint256 public gameStartTimestamp;\n    uint256 public gameEndTimestamp;\n    uint8 public playerContinuedCount;\n    uint8 public playerReadyCount;\n    uint256 public totalPrizePool;  //奖池金额\n    uint8 public bankerFeePercent; // 庄家费用百分比\n    uint8 public liquidatorFeePercent; // 清算人费用百分比\n    uint256 public implementationVersion; // 实现版本号\n\n    // 玩家数据\n    BBPlayer[] public players;\n\n    // 发牌记录\n    BBCardDealer.DealerState private dealerState;\n\n    //主合约地址\n    address public gameMainAddr;\n    address public rewardPoolAddr; // 奖励池合约地址\n    address public roomCardAddr; // 房间卡合约地址\n\n    // 添加超时相关状态变量\n    uint256 public playerTimeout; // 玩家操作超时时间，单位为秒\n    uint256 public currentRoundDeadline; // 当前回合的截止时间\n    uint256 public liquidateDeadline; // 超时清算时间\n\n    uint256 public tableInactiveTimeout; // 游戏桌不活跃超时时间，单位为秒\n    uint256 public lastActivityTimestamp; // 最后活动时间戳\n\n    //庄家奖励\n    address public rewardAddr; // 奖励地址\n    uint256 public rewardAmount; // 奖励金额\n\n    string public chatGroupId; // 聊天组ID\n\n    // 预留 25 个 slot 给将来新增变量用，防止存储冲突\n    uint256[25] private __gap;\n\n    // 事件\n    event GameTableChanged(address indexed tableAddr);\n    event GameTableInitialized(address indexed tableAddr, address indexed banker, uint256 version);\n    event CreateGameHistory(address indexed tableAddr, uint256 round, uint256 gameStartTimestamp, uint256 gameEndTimestamp, address[] playerAddrs, address[] winnerAddrs, uint256[] playerBets, uint8[5][] playerCards);\n\n\n    // 修改构造函数，传入初始所有者\n    constructor() Ownable(msg.sender){\n        // 构造函数体可以为空，因为所有权已经在 Ownable 构造函数中设置\n    }\n   \n    /**\n     * @dev 初始化函数，替代构造函数\n     */\n    function initialize(\n        uint256 _tableId,\n        string memory _tableName,\n        address _bankerAddr,\n        uint256 _betAmount,\n        uint8 _maxPlayers,\n        address _gameMainAddr,\n        uint8 _bankerFeePercent,\n        uint8 _firstRaise,\n        uint8 _secondRaise,\n        uint256 _rewardPoolId,\n        uint256 _implementationVersion\n    ) external {\n        // 确保只初始化一次的检查\n        require(creationTimestamp == 0, \"Already initialized\");\n        \n        _transferOwnership(_gameMainAddr);\n\n        // 参数验证\n        require(_maxPlayers >= 2, \"Invalid max players\");\n\n        active = true;\n        tableId = _tableId;\n        tableName = _tableName;\n        bankerAddr = _bankerAddr;\n        betAmount = _betAmount;\n        maxPlayers = _maxPlayers;\n        state = GameState.WAITING;\n        gameMainAddr = _gameMainAddr;\n        creationTimestamp = block.timestamp;\n        lastActivityTimestamp = block.timestamp; // 初始化最后活动时间\n        bankerFeePercent = _bankerFeePercent;\n        implementationVersion = _implementationVersion;\n\n        firstBetX = _firstRaise;\n        secondBetX = _secondRaise;\n\n        refreshConfig();\n\n        if(_rewardPoolId > 0){\n            IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n            require(rewardPool.isBankerPool(bankerAddr, _rewardPoolId), \"Invalid reward pool\");\n        }\n        rewardPoolId = _rewardPoolId;\n\n        emit GameTableInitialized(address(this), _bankerAddr, _implementationVersion);\n    }\n\n    //刷新游戏配置\n    function refreshConfig() internal {\n        IGameMain gameMain = IGameMain(gameMainAddr);\n        GameConfig memory config = gameMain.getGameConfig();\n        playerTimeout = config.playerTimeout;\n        liquidatorFeePercent = config.liquidatorFeePercent;\n        tableInactiveTimeout = config.tableInactiveTimeout;\n        roomCardAddr = config.roomCardAddress;\n        rewardPoolAddr = config.rewardPoolAddress;\n    }\n\n    // 添加一个公共函数来获取玩家地址列表，数组需要显示定义get函数，int、string等不需要\n    function getPlayerAddresses() public view returns (address[] memory) {\n        // 如果没有玩家，直接返回空数组\n        if (playerCount == 0) {\n            return new address[](0);\n        }\n\n        address[] memory playerAddresses = new address[](playerCount);\n        uint count = 0;\n        for(uint i = 0; i < players.length; i++){\n            if(players[i].addr != address(0)){\n                playerAddresses[count] = players[i].addr;\n                count++;\n            }\n        }\n\n        return playerAddresses;\n    }\n\n    // 添加编辑table的函数\n    function editGameTable(\n        string memory _tableName,\n        uint256 _betAmount,\n        uint8 _maxPlayers,\n        uint8 _bankerFeePercent,\n        uint8 _firstRaise,\n        uint8 _secondRaise,\n        uint256 _rewardPoolId\n    ) external onlyBanker nonReentrant {\n        require(state == GameState.WAITING && playerCount == 0, \"Invalid game state or player count not equal zero\");\n\n        IGameMain gameMain = IGameMain(gameMainAddr);\n        GameConfig memory config = gameMain.getGameConfig();\n        \n        require(_betAmount != 0, \"Bet amount too small\");\n        require(_maxPlayers > 0 && _maxPlayers <= config.maxPlayers, \"Invalid max players\");\n        require(_bankerFeePercent <= config.maxBankerFeePercent, \"Invalid banker fee percent\");\n        require(bytes(_tableName).length > 0 && bytes(_tableName).length <= 20, \"Invalid table name\");\n        require(_firstRaise >= 1 && _firstRaise <= 4, \"Invalid first raise\");\n        require(_secondRaise >= 1 && _secondRaise <= 4, \"Invalid second raise\");\n\n        if(_rewardPoolId > 0){\n            IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n            require(rewardPool.isBankerPool(bankerAddr, _rewardPoolId), \"Invalid reward pool\");\n        }\n        \n        tableName = _tableName;\n        betAmount = _betAmount;\n        maxPlayers = _maxPlayers;\n        bankerFeePercent = _bankerFeePercent;\n        firstBetX = _firstRaise;\n        secondBetX = _secondRaise;\n        rewardPoolId = _rewardPoolId;\n        \n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 更新最后活动时间\n     */\n    function _updateLastActivity() internal {\n        lastActivityTimestamp = block.timestamp;\n    }\n\n    modifier onlyParticipant() {\n        if(msg.sender != bankerAddr) {\n            _getPlayer(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @dev 修饰器：适用于庄家\n     */\n    modifier onlyBanker() {\n        require(msg.sender == bankerAddr, \"not banker\");\n        _;\n    }\n\n    /**\n     * @dev 修饰器：适用于玩游戏的玩家，如果庄家也参与游戏，那也算在内\n     */\n    modifier onlyPlayers() {\n        _getPlayer(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev 修饰器：只允许游戏主合约调用\n     */\n    modifier onlyGameMain() {\n        require(msg.sender == gameMainAddr, \"only main contract can call\");\n        _;\n    }\n\n\n    /**\n     * @dev 庄家为游戏桌设置奖励池\n     * @param poolId 奖励池ID\n     */\n    function setTableRewardPool(uint256 poolId) external onlyBanker nonReentrant {\n        require(rewardPoolAddr != address(0), \"Invalid reward pool address\");\n        bool isBankerPool = IRewardPool(rewardPoolAddr).isBankerPool(bankerAddr, poolId);\n        require(isBankerPool, \"poolId is not your pool\");\n\n        rewardPoolId = poolId;\n    }\n\n    /**\n     * @dev 庄家移除游戏桌的奖励池\n     */\n    function removeTableRewardPool() external onlyBanker nonReentrant {\n        rewardPoolId = 0;\n    }\n\n    //添加玩家\n    function _addPlayer(address playerAddr) internal returns (uint256) {\n        //遍历players找到空闲的位置\n        for(uint8 i = 0; i < players.length; i++){\n            if(players[i].addr == address(0)){\n                players[i].addr = playerAddr;\n                players[i].state = PlayerState.JOINED;\n                players[i].totalBet = 0;\n                players[i].hasActedThisRound = false;\n                players[i].cards = [0, 0, 0, 0, 0];\n                players[i].cardType = CardType.NONE;\n                playerCount++;\n                return i;\n            }\n        }\n\n        players.push(BBPlayer({\n            addr: playerAddr,\n            state: PlayerState.JOINED,\n            totalBet: 0,\n            hasActedThisRound: false,\n            isWinner: false,\n            cards: [0, 0, 0, 0, 0],\n            cardType: CardType.NONE,\n            __gap: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)]\n        })); \n\n        playerCount++;\n        return players.length - 1;   \n    }\n\n    function _getPlayerIndex(address playerAddr) internal view returns (uint8) {\n        for (uint8 i = 0; i < players.length; i++) {\n            if (players[i].addr == playerAddr) {\n                return i;\n            }\n        }\n        require(false, \"Player not found\");\n        return 0;\n    }\n\n    function _getPlayer(address playerAddr) internal view returns (uint8 index, BBPlayer storage) {\n        uint8 playerIndex = _getPlayerIndex(playerAddr);\n        return (playerIndex, players[playerIndex]);\n    }\n\n    //移除玩家\n    function _removePlayer(address playerAddr) internal {\n        uint8 index = _getPlayerIndex(playerAddr);\n        _removePlayerByIndex(index);\n    }\n\n    function _removePlayerByIndex(uint8 index) internal {\n        players[index].addr = address(0);\n        players[index].state = PlayerState.NONE;\n        players[index].totalBet = 0;\n        players[index].hasActedThisRound = false;\n        players[index].isWinner = false;\n        players[index].cards = [0, 0, 0, 0, 0];\n        players[index].cardType = CardType.NONE;\n\n        playerCount--;\n    }\n\n    function _isPlayerExists(address playerAddr) internal view returns (bool) {\n        for (uint8 i = 0; i < players.length; i++) {\n            if (players[i].isValid() && players[i].addr == playerAddr) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // 更新聊天群组ID\n    function updateChatGroupId(string memory _chatGroupId) external onlyBanker {\n        chatGroupId = _chatGroupId;\n        emit GameTableChanged(address(this));\n    }\n\n\n    /**\n     * @dev 玩家加入游戏\n     */\n    function playerJoin() external nonReentrant {\n        address playerAddr = msg.sender;\n        require(!_isPlayerExists(playerAddr), \"Player already joined\");\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        require(playerCount < maxPlayers, \"Max players reached\");\n\n        _addPlayer(playerAddr);\n\n        _updateLastActivity();\n\n        IGameMain(gameMainAddr).userJoinTable(playerAddr);\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家准备\n     */\n    function playerReady(bytes32 randomValue) external payable onlyPlayers nonReentrant {\n        require(randomValue != bytes32(0), \"Invalid random value\");\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        address playerAddr = msg.sender;\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.JOINED, \"Player not in joined state\");\n        require(msg.value == betAmount, \"Insufficient funds\");\n\n        player.totalBet = betAmount;\n        totalPrizePool += betAmount;\n        playerReadyCount++;\n\n        player.playerReady();\n\n        _updateLastActivity();\n\n        _updateFinalSeed(randomValue);\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家取消准备\n     */\n    function playerUnready() external payable onlyPlayers nonReentrant {\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        address playerAddr = msg.sender;\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.READY, \"Player not in ready state\");\n\n        totalPrizePool -= betAmount;\n        playerReadyCount--;\n        player.totalBet = 0;\n\n        player.playerUnready();\n\n        _updateLastActivity();\n\n        // 返还押金给玩家 - 使用更安全的 call 方法而不是 transfer\n        (bool success, ) = payable(playerAddr).call{value: betAmount}(\"\");\n        require(success, \"transfer failed\");\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家退出游戏\n     */\n    function playerQuit() external payable onlyPlayers nonReentrant {\n        require(state == GameState.WAITING || state == GameState.SETTLED || state == GameState.LIQUIDATED, \"Game not in waiting or settled state\");\n        address playerAddr = msg.sender;\n        (uint8 playerIndex, BBPlayer storage player) = _getPlayer(playerAddr);\n        if(state == GameState.WAITING){\n            require(player.state == PlayerState.JOINED || player.state == PlayerState.READY, \"Player not in JOINED or READY state\");\n\n            // 先保存需要返还的金额\n            uint256 amountToReturn = player.totalBet;\n\n            if(player.state == PlayerState.READY){\n                playerReadyCount--;\n                totalPrizePool -= amountToReturn;\n            }\n\n            // 移除玩家\n            _removePlayerByIndex(playerIndex);\n\n            if(amountToReturn > 0){\n                //返还押金\n                (bool success, ) = payable(playerAddr).call{value: amountToReturn}(\"\");\n                require(success, \"transfer failed\");\n            }\n        }else{\n            // 移除玩家\n            _removePlayerByIndex(playerIndex);\n        }  \n        \n        IGameMain(gameMainAddr).userLeaveTable(playerAddr);\n\n        _updateLastActivity();\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 庄家移除玩家\n     */\n    function bankerRemovePlayer(address playerAddr) external onlyBanker nonReentrant {\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        require(playerAddr != bankerAddr, \"Can not remove banker\");\n        (uint8 playerIndex, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.JOINED, \"Player not in joined state\");\n\n        _removePlayerByIndex(playerIndex);\n        _updateLastActivity();\n\n        IGameMain(gameMainAddr).userLeaveTable(playerAddr);\n\n        emit GameTableChanged(address(this));\n    }\n\n    function _updateFinalSeed(bytes32 randomValue) internal {\n        finalSeed = uint256(keccak256(abi.encodePacked(\n            finalSeed,\n            block.prevrandao,\n            block.timestamp,\n            msg.sender,\n            randomValue\n        )));\n    }\n\n    function startGame(uint256 roomCardId, bytes32 randomValue) external payable onlyBanker nonReentrant {\n        require(randomValue!= bytes32(0), \"Invalid random value\");\n        // 刷新游戏数据\n        refreshConfig();\n\n        require(roomCardId != 0, \"Invalid room card params\");\n        require(roomCardAddr != address(0), \"Invalid room card contract\");\n        require(playerReadyCount == playerCount, \"Not all players ready\");\n        require(state == GameState.WAITING, \"Game not in waiting state\");\n        require(playerCount >= 2, \"Not enough players\");\n\n        // 庄家需要押金\n        require(msg.value == betAmount * 2, \"Insufficient funds\");\n        bankerStakeAmount = betAmount * 2;\n\n        //验证房卡\n        IRoomCardNFT roomCard = IRoomCardNFT(roomCardAddr);\n        require(roomCard.validateParams(roomCardId, playerCount), \"Invalid room card params\");\n \n        // 消耗房卡\n        roomCard.consume(msg.sender, roomCardId);\n        \n        gameRound++;\n\n        _updateFinalSeed(randomValue);\n\n        _startFirstBetting();\n    }\n\n    function _resetGame() internal {\n        playerContinuedCount = 0;\n        gameStartTimestamp = 0;\n        gameEndTimestamp = 0;\n        currentRoundDeadline = 0;\n        liquidateDeadline = 0;\n        bankerStakeAmount = 0;\n        playerReadyCount = 0;\n        totalPrizePool = 0;\n        rewardAddr = address(0);\n        rewardAmount = 0;\n        dealerState.reset();\n        for(uint i = 0; i < players.length; i++){\n            if(players[i].isValid()){\n                players[i].playerReset();\n            }  \n        }\n    }\n\n    function _canSettleGame() internal view returns (bool) {\n        if(state == GameState.WAITING || state == GameState.SETTLED || state == GameState.LIQUIDATED){\n            return false;\n        }\n        if(state == GameState.ENDED){\n            return true;\n        }\n\n\n        if(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING){\n            (uint8 foldedCount, uint8 totalActed) = _getPlayerActionCounts();\n\n            bool onlyOneLeft = playerContinuedCount == 1 && foldedCount == playerCount - 1;\n            bool noOneLeft = foldedCount == playerCount;\n            bool isDeadlinePassed = _isTimeOut();\n            bool noOneActed = totalActed == 0;\n            bool lessOneContinued = playerContinuedCount <= 1;  //小于等于一个人继续\n\n            if (onlyOneLeft || noOneLeft || (isDeadlinePassed && lessOneContinued) || (isDeadlinePassed && noOneActed)) {\n                // 可以结算\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev 下一步\n     */\n    function nextStep(bytes32 randomValue) external onlyBanker nonReentrant {\n        require(randomValue != bytes32(0), \"Invalid random value\");\n        if(_canSettleGame()){\n            _settleGame();\n\n            _updateFinalSeed(randomValue);\n            _updateLastActivity();\n            emit GameTableChanged(address(this));\n            return;\n        }\n        \n        (bool canMove, , string memory reason) = canMoveToNextStep();\n        require(canMove, reason);\n        if(state == GameState.FIRST_BETTING) {\n            _startSecondBetting();\n        }\n        else if(state == GameState.SECOND_BETTING) {\n            _endGame();\n        }\n        else if(state == GameState.SETTLED || state == GameState.LIQUIDATED) {\n            _resetGame();\n            setState(GameState.WAITING);\n        }\n\n        // 将所有人设置为未操作状态\n        for(uint i = 0; i < players.length; i++){\n            if(players[i].isValid()){\n                players[i].hasActedThisRound = false;\n            }\n        }\n        \n        _updateFinalSeed(randomValue);\n        _updateLastActivity();\n        emit GameTableChanged(address(this));\n    }\n\n    function _dealCardsByRound(uint8 round) internal {\n        dealerState.initialize(finalSeed);\n        if(round == 1){\n            // 第一轮发牌，每个玩家发3张牌\n            for(uint i = 0; i < players.length; i++){\n                if(players[i].isValid()){\n                    uint8[] memory newCards = dealerState.dealCardsByRoundForPlayer(players[i].addr, round);\n                    for(uint j = 0; j < 3; j++){\n                        players[i].cards[j] = newCards[j];\n                    }\n                }\n            }\n        }else{\n            // 第二、三轮发牌\n            for(uint i = 0; i < players.length; i++){\n                if(players[i].isValid() && players[i].state == PlayerState.ACTIVE){\n                    uint8[] memory newCards = dealerState.dealCardsByRoundForPlayer(players[i].addr, round);\n                    // 合并第一轮和第二轮的牌\n                    for(uint j = 0; j < newCards.length; j++){\n                        players[i].cards[j + round + 1] = newCards[j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev 检查揭示阶段状态，如果所有玩家都已揭示或超时，完成会话并进入下注阶段\n     */\n    function _startFirstBetting() internal {\n        // 将所有玩家设置成active状态\n        for (uint256 i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                player.state = PlayerState.ACTIVE;\n            }\n        }\n\n        // 初始化发牌状态\n        dealerState.reset();\n\n        // 第一轮发牌\n        _dealCardsByRound(1);\n\n        // 进入第一轮下注\n        setState(GameState.FIRST_BETTING);\n    }\n\n    function _getPlayerActionCounts() internal view returns (uint8, uint8){\n        uint8 foldedCount = 0;\n        uint8 actedCount = 0;\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                if(player.state == PlayerState.FOLDED){\n                    foldedCount++;\n                }\n                if(player.hasActedThisRound){\n                    actedCount++;\n                }\n            }\n        }\n\n        return (foldedCount, actedCount);\n    }\n\n    \n\n    function _startSecondBetting() internal {\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid() && !player.hasActedThisRound){\n                player.playerFold();\n            }\n        }\n\n        _dealCardsByRound(2);\n        setState(GameState.SECOND_BETTING);\n        playerContinuedCount = 0;\n    }\n\n    function _endGame() internal {\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid() && !player.hasActedThisRound){\n                player.playerFold();\n            }\n        }\n\n        _dealCardsByRound(3);\n        setState(GameState.ENDED);\n        _settleGame();\n    }\n\n    function _allPlayersActed() public view returns (bool){\n        for(uint i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                if(player.state != PlayerState.FOLDED && !player.hasActedThisRound){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function canMoveToNextStep() public view returns (bool canMove, string memory title, string memory reason) {\n        if (state == GameState.LIQUIDATED) {\n            return (true, \"Play Again\", \"Game has been liquidated\");\n        }else if(state == GameState.SETTLED){\n            return (true, \"Play Again\", \"\");\n        }else if (state == GameState.ENDED) {\n            return (true, \"Settle Game\", \"\");\n        }else if (state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING) {\n\n            if (playerCount == 0) {\n                // 如果没有玩家，直接返回\n                return (false, \"\", \"No players in game\");\n            }\n\n            bool isDeadlinePassed = _isTimeOut();\n            bool allPlayersActed = _allPlayersActed();\n\n            if (_canSettleGame()) {\n                return (true, \"Settle Game\", \"\");\n            } else if (allPlayersActed || isDeadlinePassed) {\n                return (true, \"Next Round\", \"\");\n            } else {\n                return (false, \"Next Round\", \"Waiting for players to act\");\n            }\n        }\n\n        return (false, \"\", \"Unknown state\");\n    }\n\n\n    function _isTimeOut() internal view returns (bool) {\n        return currentRoundDeadline > 0 && block.timestamp > currentRoundDeadline;\n    }\n\n    /**\n     * @dev 玩家弃牌\n     */\n    function playerFold(bytes32 randomValue) external onlyPlayers nonReentrant{\n        require(randomValue!= bytes32(0), \"Invalid random value\");\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Game not in playing state\");\n        address playerAddr = msg.sender;\n\n        // 检查是否超时\n        require(!_isTimeOut(), \"action timeout\");\n\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.ACTIVE && player.hasActedThisRound == false, \"Player not in active state or has acted\");\n\n        _updateLastActivity();\n        player.playerFold();\n\n        _updateFinalSeed(randomValue);\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 玩家继续游戏\n     */\n    function playerContinue(bytes32 randomValue) external payable onlyPlayers nonReentrant{\n        require(randomValue!= bytes32(0), \"Invalid random value\");\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Game not in playing state\");\n        address playerAddr = msg.sender;\n\n        uint256 needBetAmount = 0;\n\n        if(state == GameState.FIRST_BETTING){\n            needBetAmount = betAmount * firstBetX;\n        }else{\n            needBetAmount = betAmount * secondBetX;\n        }\n\n        require(msg.value == needBetAmount, \"Insufficient funds\");\n\n        // 检查是否超时\n        require(!_isTimeOut(), \"action timeout\");\n\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        require(player.state == PlayerState.ACTIVE && player.hasActedThisRound == false, \"Player not in active state or has acted\");\n\n        player.playerContinue(needBetAmount);\n        playerContinuedCount++;\n        totalPrizePool += needBetAmount;\n\n        _updateLastActivity();\n\n        _updateFinalSeed(randomValue);\n\n        emit GameTableChanged(address(this));\n    }\n\n    function _gameTimeout() internal view returns (bool)  {\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING, \"Game not in playing state\"); \n\n        // 检查是否超时\n        return block.timestamp > lastActivityTimestamp + tableInactiveTimeout;\n    }\n\n    /**\n     * @dev 玩家结算游戏，如果庄家没结算的话\n     */\n    function playerSettle() external payable onlyPlayers nonReentrant{\n        require(_gameTimeout(), \"Game not timeout\");\n\n        _settleGame();\n    }\n\n    function _settleGame() internal {\n        setState(GameState.SETTLED);\n\n        gameEndTimestamp = block.timestamp;\n\n\n        bool noOneContinued = playerContinuedCount == 0;\n\n        // 计算费用\n        uint256 bankerFee = (totalPrizePool * bankerFeePercent) / 100;\n        if(noOneContinued){\n            // 如果没有人继续，庄家不收取费用\n            bankerFee = 0;\n        }\n        uint256 remainingPrizePool = totalPrizePool - bankerFee;\n\n        uint256 bankerTotal = bankerFee + bankerStakeAmount;\n        bankerStakeAmount = 0;\n\n        // 如果只有一个玩家继续，则该玩家获胜\n        if (playerContinuedCount == 1) {\n            _settleOneContinuedPlayer(remainingPrizePool);\n        }\n        // 如果没有人继续，则每个人拿回自己的钱\n        else if (noOneContinued) {\n            _settleAllFolded();\n        }\n        // 正常比牌\n        else {\n            _settleNormalGame(remainingPrizePool);\n        }\n\n        // 统一处理庄家费用转账，庄家抽成+庄家押金\n        if (bankerTotal > 0) {\n            totalIncome += bankerFee;\n            (bool success, ) = payable(bankerAddr).call{value: bankerTotal}(\"\");\n            require(success, \"transfer to banker failed\");\n        }\n\n        // 如果设置了奖励池，尝试分配奖励\n        if (rewardPoolAddr != address(0) && rewardPoolId != 0) {\n            address[] memory playerAddresses = getPlayerAddresses();\n            IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n            try rewardPool.tryDistributeReward(rewardPoolId, playerAddresses, finalSeed) returns (address winAddr, uint256 winAmount){\n                if(winAddr != address(0)){\n                    // 有人获奖，设置获奖的人信息\n                    rewardAddr = winAddr;\n                    rewardAmount = winAmount;\n                }\n            } catch {\n            }\n        }\n\n        emit GameTableChanged(address(this));\n    }\n\n    /**\n     * @dev 处理只有一个玩家继续的情况\n     */\n    function _settleOneContinuedPlayer(uint256 remainingPrizePool) internal {\n        // 准备游戏结果数据\n        address[] memory winnerAddrs = new address[](1);\n        uint256[] memory playerBets = new uint256[](playerCount);\n        uint8[5][] memory playerCards = new uint8[5][](playerCount);\n        address[] memory playerAddresses = new address[](playerCount);\n        uint256 winnerCount = 0;\n\n        // 找出继续的那个玩家\n        address continuedPlayer = address(0);\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if (player.isValid()) {\n                // 找出继续的玩家\n                if (player.state == PlayerState.ACTIVE &&\n                    player.hasActedThisRound) {\n                    continuedPlayer = player.addr;\n                    winnerAddrs[winnerCount] = player.addr;\n                    player.isWinner = true;\n                    winnerCount++;\n                }\n\n                playerBets[index] = player.totalBet;\n                playerCards[index] = player.cards;\n                playerAddresses[index] = player.addr;\n\n                index++;\n            }\n        }\n\n        // 将剩余奖池给获胜者\n        if (continuedPlayer != address(0)) {\n            (bool success, ) = payable(continuedPlayer).call{value: remainingPrizePool}(\"\");\n            require(success, \"transfer to winners failed\");\n        }\n\n        emit CreateGameHistory(address(this), gameRound, gameStartTimestamp, gameEndTimestamp, playerAddresses, winnerAddrs, playerBets, playerCards);\n    }\n\n    /**\n     * @dev 处理所有玩家都弃牌的情况\n     */\n    function _settleAllFolded() internal {\n        // 创建临时数组来存储需要返还资金的玩家和金额\n        address[] memory refundAddresses = new address[](playerCount);\n        uint256[] memory refundAmounts = new uint256[](playerCount);\n        uint256[] memory playerBets = new uint256[](playerCount);\n        uint8[5][] memory playerCards = new uint8[5][](playerCount);\n        address[] memory playerAddresses = new address[](playerCount);\n        address[] memory winnerAddrs = new address[](0);\n        uint256 refundCount = 0;\n\n        // 收集所有玩家数据并计算需要返还的金额\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            if (players[i].isValid()) {\n                BBPlayer storage player = players[i];\n\n                // 计算需要返还的金额（玩家的所有押注）\n                uint256 refundAmount = player.totalBet;\n                if (refundAmount > 0) {\n                    refundAddresses[refundCount] = player.addr;\n                    refundAmounts[refundCount] = refundAmount;\n                    refundCount++;\n                }\n\n                playerBets[index] = players[i].totalBet;\n                playerCards[index] = players[i].cards;\n                playerAddresses[index] = players[i].addr;\n                index++;\n            }        \n        }\n\n        // 返还每个玩家的押注\n        for (uint i = 0; i < refundCount; i++) {\n            (bool success, ) = payable(refundAddresses[i]).call{value: refundAmounts[i]}(\"\");\n            require(success, \"refund failed\");\n        }\n\n        emit CreateGameHistory(address(this), gameRound, gameStartTimestamp, gameEndTimestamp, playerAddresses, winnerAddrs, playerBets, playerCards);\n    }\n\n\n    /**\n     * @dev 处理正常比牌的情况\n     */\n    function _settleNormalGame(uint256 remainingPrizePool) internal {\n        CardType _maxCardType = CardType.NONE;\n\n        // 准备游戏结果数据\n        address[] memory winnerAddrs = new address[](playerCount);\n        uint256[] memory playerBets = new uint256[](playerCount);\n        uint8[5][] memory playerCards = new uint8[5][](playerCount);\n        address[] memory playerAddresses = new address[](playerCount);\n        uint256 winnerCount = 0;\n\n\n        // 计算每个玩家的牌型\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if (player.isValid()) {\n                player.cardType = BBCardUtils.calculateCardType(player.cards);\n                // 更新最大牌型\n                if (uint8(player.cardType) > uint8(_maxCardType)) {\n                    _maxCardType = player.cardType;\n                }\n\n                playerBets[index] = player.totalBet;\n                playerCards[index] = player.cards;\n                playerAddresses[index] = player.addr;\n                index++;\n            }\n        }\n\n        // 如果所有玩家都没有牛牌型，则比较最大牌\n        if (_maxCardType == CardType.NO_BULL) {\n            (winnerAddrs, winnerCount) = _settleNormalGameWithNoBull();\n        } else {\n            // 找出获胜者（有牛牌型的情况）\n            for (uint i = 0; i < players.length; i++) {\n                BBPlayer storage player = players[i];\n                if (player.isValid()) {\n                    // 如果是获胜者，添加到获胜者数组\n                    if (player.cardType == _maxCardType) {\n                        winnerAddrs[winnerCount] = player.addr;\n                        player.isWinner = true;\n                        winnerCount++;\n                    }\n                }\n            }\n        }\n\n        // 调整获胜者数组大小\n        assembly (\"memory-safe\")  {\n            mstore(winnerAddrs, winnerCount)\n        }\n\n\n        // 分配奖金给获胜者\n        if (winnerCount > 0) {\n            // 每个获胜者应得的奖金\n            uint256 prizePerWinner = remainingPrizePool / winnerCount;\n\n            // 分配奖金给每个获胜者\n            for (uint i = 0; i < winnerCount; i++) {\n                address winnerAddr = winnerAddrs[i];\n                (bool success, ) = payable(winnerAddr).call{value: prizePerWinner}(\"\");\n                require(success, \"transfer to winners failed\");\n            }\n\n            // 处理可能的舍入误差，将剩余的少量奖金给第一个获胜者\n            uint256 remainingPrize = remainingPrizePool - (prizePerWinner * winnerCount);\n            if (remainingPrize > 0) {\n                (bool success, ) = payable(winnerAddrs[0]).call{value: remainingPrize}(\"\");\n                require(success, \"transfer to winners failed\");\n            }\n        }\n\n        emit CreateGameHistory(address(this), gameRound, gameStartTimestamp, gameEndTimestamp, playerAddresses, winnerAddrs, playerBets, playerCards);\n    }\n\n    /**\n     * @dev 处理没有牛牌型的情况\n     */\n    function _settleNormalGameWithNoBull() internal view returns (address[] memory, uint256){\n        uint8 maxCard = 0;\n        uint256 winnerCount = 0;\n        address[] memory winnerAddrs = new address[](playerCount);\n\n        // 先找出所有玩家中的最大牌\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                // 找出玩家五张牌中的最大牌\n                uint8 playerMaxCard = 0;\n                for (uint j = 0; j < 5; j++) {\n                    uint8 cardValue = player.cards[j] % 13;\n                    // 修正：A是最小的(值为1)，K是最大的(值为13)\n                    if (cardValue == 0) cardValue = 1; // A的值为1\n                    if (cardValue > playerMaxCard) {\n                        playerMaxCard = cardValue;\n                    }\n                }\n\n                // 更新全局最大牌\n                if (playerMaxCard > maxCard) {\n                    maxCard = playerMaxCard;\n                }\n            }\n        }\n\n        // 找出拥有最大牌的玩家\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid()){\n                // 检查玩家是否有最大牌\n                uint8 playerMaxCard = 0;\n                for (uint j = 0; j < 5; j++) {\n                    uint8 cardValue = player.cards[j] % 13;\n                    // 修正：A是最小的(值为1)，K是最大的(值为13)\n                    if (cardValue == 0) cardValue = 1; // A的值为1\n                    if (cardValue > playerMaxCard) {\n                        playerMaxCard = cardValue;\n                    }\n                }\n\n                if (playerMaxCard == maxCard) {\n                    winnerAddrs[winnerCount] = player.addr;\n                    winnerCount++;\n                }\n            }  \n        }\n\n        // 调整获胜者数组大小\n        assembly (\"memory-safe\")  {\n            mstore(winnerAddrs, winnerCount)\n        }\n\n        return (winnerAddrs, winnerCount);\n    }\n\n    /**\n     * @dev 清算不活跃的游戏桌\n     * 此函数来清算长时间不活跃的游戏桌\n     * 庄家的押金将被分配给玩家和清算人\n     */\n    function liquidateGame() external onlyPlayers nonReentrant {\n        // 检查游戏桌是否超时\n        require(msg.sender != bankerAddr, \"Banker cannot liquidate\");\n        require(state == GameState.FIRST_BETTING || state == GameState.SECOND_BETTING || state == GameState.ENDED, \"Table not in gaming\");\n\n        require(block.timestamp > liquidateDeadline, \"Game not timeout\");\n\n        setState(GameState.LIQUIDATED);\n\n        uint256 bankerFunds = bankerStakeAmount;\n        // 计算有多少玩家可以分配奖励（不包括庄家）\n        uint8 eligiblePlayerCount = 0;\n        for(uint8 i = 0; i < players.length; i++){\n            BBPlayer storage player = players[i];\n            if(player.isValid() && player.addr != bankerAddr){\n                eligiblePlayerCount++;\n            }\n            if(player.addr == bankerAddr){\n                bankerFunds += player.totalBet;\n            }\n        }\n\n        // 清算人的奖励 (从庄家押金和玩游戏的资金中收取)\n        uint256 liquidatorReward = bankerFunds * liquidatorFeePercent / 100;\n\n        // 剩余的庄家押金平均分配给所有玩家\n        uint256 remainingBankerBet = bankerFunds - liquidatorReward;\n        uint256 playerRewardTotal = 0;\n\n        \n\n        // 创建临时数组存储需要支付的地址和金额\n        address[] memory paymentAddresses = new address[](eligiblePlayerCount);\n        uint256[] memory paymentAmounts = new uint256[](eligiblePlayerCount);\n        uint256 paymentCount = 0;\n\n\n        // 计算每个玩家的奖励\n        uint256 rewardPerPlayer = remainingBankerBet / eligiblePlayerCount;\n\n        // 计算每个玩家应得的金额\n        for (uint i = 0; i < players.length; i++) {\n            BBPlayer storage player = players[i];\n            if(player.isValid() && player.addr != bankerAddr){\n                uint256 totalPayment = 0;\n\n                // 计算玩家应得的总金额（押金 + 奖励）\n                totalPayment += player.totalBet;\n\n                // 添加奖励金额\n                totalPayment += rewardPerPlayer;\n\n                // 记录需要支付的金额\n                if (totalPayment > 0) {\n                    paymentAddresses[paymentCount] = player.addr;\n                    paymentAmounts[paymentCount] = totalPayment;\n                    paymentCount++;\n                }\n\n                playerRewardTotal += rewardPerPlayer;\n            }\n        }\n        \n\n        // 处理可能的舍入误差\n        uint256 actualDistributed = playerRewardTotal + liquidatorReward;\n        if (actualDistributed < bankerFunds) {\n            liquidatorReward += (bankerFunds - actualDistributed);\n        }\n\n        // _resetGame();\n        gameLiquidatedCount++;\n\n\n        // 所有状态更新完成后，进行转账操作\n        // 然后进行其他转账\n        for (uint i = 0; i < paymentCount; i++) {\n            (bool otherSuccess, ) = payable(paymentAddresses[i]).call{value: paymentAmounts[i]}(\"\");\n            require(otherSuccess, \"transfer to players failed\");\n        }\n\n        // 支付清算人奖励\n        (bool liquidatorSuccess, ) = payable(msg.sender).call{value: liquidatorReward}(\"\");\n        require(liquidatorSuccess, \"transfer to liquidator failed\");\n\n        emit GameTableChanged(address(this));\n    }\n\n\n    /**\n     * @dev 设置游戏状态\n     */\n    function setState(GameState _state) internal {\n        state = _state;\n\n        // 如果进入下注阶段，为所有玩家设置操作截止时间\n        if (_state == GameState.FIRST_BETTING || _state == GameState.SECOND_BETTING) {\n            currentRoundDeadline = block.timestamp + playerTimeout;\n            liquidateDeadline = block.timestamp + tableInactiveTimeout;\n        }\n        if(_state == GameState.ENDED){\n            liquidateDeadline = block.timestamp + tableInactiveTimeout;\n        }\n\n        _updateLastActivity(); // 更新最后活动时间\n\n        emit GameTableChanged(address(this));\n    }\n\n    // 获取所有玩家数据\n    function getAllPlayerData() external view returns (BBPlayer[] memory) {\n        BBPlayer[] memory playerData = new BBPlayer[](playerCount);\n        uint8 index = 0;\n        for (uint i = 0; i < players.length; i++) {\n            if(players[i].isValid()){\n                playerData[index] = players[i];\n                playerData[index].cardType = BBCardUtils.calculateCardType(players[i].cards);\n                index++;\n            }\n        }\n\n        return playerData;\n    }\n\n\n    // 获取单个玩家数据\n    function getPlayerData(address playerAddr) external view returns (BBPlayer memory) {\n        (, BBPlayer storage player) = _getPlayer(playerAddr);\n        BBPlayer memory playerData = player;\n        playerData.cardType = BBCardUtils.calculateCardType(player.cards);\n        return playerData;\n    }\n\n\n    function getTableInfo() external view returns (GameTableView memory) {\n        IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n        (bool canNext, string memory nextTitle, string memory nextReason) = canMoveToNextStep();\n        // 创建一个空的 RewardPoolInfo 结构体\n        RewardPoolInfo memory emptyRewardPoolInfo;\n        if (rewardPoolId != 0) {\n            emptyRewardPoolInfo = rewardPool.getRewardPoolInfo(bankerAddr, rewardPoolId);\n        }\n\n        return GameTableView({\n            // balance: address(this).balance / 1 ether,\n            active: active,\n            gameRound: gameRound,\n            gameLiquidatedCount: gameLiquidatedCount,\n            tableAddr: address(this),\n            tableId: tableId,\n            tableName: tableName,\n            bankerAddr: bankerAddr,\n            betAmount: betAmount,\n            bankerFeePercent: bankerFeePercent,\n            totalPrizePool: totalPrizePool,\n            playerCount: playerCount,\n            maxPlayers: maxPlayers,\n            creationTimestamp: creationTimestamp,\n            liquidateDeadline: liquidateDeadline,\n            state: state,\n            liquidatorFeePercent: liquidatorFeePercent,\n            playerContinuedCount: playerContinuedCount,\n            playerReadyCount: playerReadyCount,\n            playerAddresses: getPlayerAddresses(),\n            currentRoundDeadline: currentRoundDeadline,\n            playerTimeout: playerTimeout,\n            tableInactiveTimeout: tableInactiveTimeout,\n            lastActivityTimestamp: lastActivityTimestamp,\n            rewardPoolId: rewardPoolId,\n            rewardPoolInfo: emptyRewardPoolInfo, // 奖励池信息，如果没有奖励池，则返回空结构体\n            implementationVersion: implementationVersion,\n            firstBetX: firstBetX,\n            secondBetX: secondBetX,\n            bankerStakeAmount: bankerStakeAmount,\n            canNext: canNext,\n            nextTitle: nextTitle,\n            nextReason: nextReason,\n            rewardAddr: rewardAddr,\n            rewardAmount: rewardAmount,\n            chatGroupId: chatGroupId\n        });\n    }\n\n    function getTableInfoShort() external view returns (GameTableInfoShort memory) {\n        IRewardPool rewardPool = IRewardPool(rewardPoolAddr);\n\n        // 创建一个空的 RewardPoolInfo 结构体\n        RewardPoolInfo memory emptyRewardPoolInfo;\n        if (rewardPoolId != 0) {\n            emptyRewardPoolInfo = rewardPool.getRewardPoolInfo(bankerAddr, rewardPoolId);\n        }\n\n        return GameTableInfoShort({\n            active: active,\n            gameRound: gameRound,\n            gameLiquidatedCount: gameLiquidatedCount,\n            tableAddr: address(this),\n            tableId: tableId,\n            tableName: tableName,\n            bankerAddr: bankerAddr,\n            betAmount: betAmount,\n            bankerFeePercent: bankerFeePercent,\n            playerCount: playerCount,\n            maxPlayers: maxPlayers,\n            state: state,\n            lastActivityTimestamp: lastActivityTimestamp,\n            rewardPoolId: rewardPoolId,\n            rewardPoolInfo: emptyRewardPoolInfo // 奖励池信息，如果没有奖励池，则返回空结构体\n        });\n    }\n\n    function isPlayer(address playerAddr) external view returns (bool) {\n        _getPlayer(playerAddr);\n        return true;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/BBInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\nimport \"./BBStructs.sol\";\r\n\r\ninterface IGameTableFactory {\r\n    function createGameTable(\r\n        uint256 tableId,\r\n        string memory tableName,\r\n        address bankerAddr,\r\n        uint256 betAmount,\r\n        uint8 maxPlayers,\r\n        address gameMainAddr,\r\n        uint8 bankerFeePercent,\r\n        uint8 firstRaise,\r\n        uint8 secondRaise,\r\n        uint256 rewardPoolId\r\n    ) external returns (address);\r\n}\r\n\r\ninterface IGameTableImplementation {\r\n    function bankerAddr() external view returns (address);\r\n    function getTableInfo() external view returns (GameTableView memory);\r\n    function getTableInfoShort() external view returns (GameTableInfoShort memory);\r\n    function lastActivityTimestamp() external view returns (uint256);\r\n    function state() external view returns (GameState);\r\n    function rewardPoolId() external view returns (uint256);\r\n    function initialize(\r\n        uint256 _tableId,\r\n        string memory _tableName,\r\n        address _bankerAddr,\r\n        uint256 _betAmount,\r\n        uint8 _maxPlayers,\r\n        address _gameMainAddr,\r\n        uint8 _bankerFeePercent,\r\n        uint8 _firstRaise,\r\n        uint8 _secondRaise,\r\n        uint256 _rewardPoolId,\r\n        uint256 _implementationVersion\r\n    ) external;\r\n}\r\n\r\ninterface IGameMain {\r\n    function isValidGameTable(address) external view returns (bool);\r\n    function liquidatorFeePercent() external view returns (uint256);\r\n    function playerTimeout() external view returns (uint256);\r\n    function tableInactiveTimeout() external view returns (uint256);\r\n    function rewardPoolAddress() external view returns (address);\r\n    function roomCardAddress() external view returns (address);\r\n    function roomLevelAddress() external view returns (address);\r\n    function getGameConfig() external view returns (GameConfig memory);\r\n    function rewardPoolIsInUse(address, uint256) external view returns (bool);\r\n    function userJoinTable(address userAddr) external;\r\n    function userLeaveTable(address userAddr) external;\r\n}\r\n\r\ninterface IRewardPool{\r\n    function tryDistributeReward(uint256 _poolId, address[] calldata _players, uint256 finalSeed) external  returns (address, uint256);\r\n    function isBankerPool(address, uint256) external view returns (bool);\r\n    function getRewardPoolInfo(address, uint256) external view returns (RewardPoolInfo memory);\r\n}\r\n\r\ninterface IRoomCardNFT{\r\n    function validateParams(uint256, uint8) external view returns (bool);\r\n    function hasNft(address) external view returns (bool);\r\n    function consume(address, uint256) external;\r\n}"
    },
    "contracts/BBPlayer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\n\r\nstruct BBPlayer {\r\n    address addr;\r\n    PlayerState state;\r\n\r\n    uint256 totalBet;\r\n\r\n    bool hasActedThisRound;   // 本轮是否已操作\r\n    bool isWinner;   // 是否为赢家\r\n\r\n    uint8[5] cards;\r\n    CardType cardType;\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\nlibrary BBPlayerLib {\r\n    /**\r\n     * @dev 玩家准备\r\n     */\r\n    function playerReady(BBPlayer storage self) internal {\r\n        self.state = PlayerState.READY;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家取消准备\r\n     */\r\n    function playerUnready(BBPlayer storage self) internal {\r\n        self.state = PlayerState.JOINED;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家加入\r\n     */\r\n    function playerJoin(BBPlayer storage self) internal {\r\n        self.state = PlayerState.JOINED;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家弃牌\r\n     */\r\n    function playerFold(BBPlayer storage self) internal {\r\n        self.state = PlayerState.FOLDED;\r\n        self.hasActedThisRound = true;\r\n    }\r\n\r\n    /**\r\n     * @dev 玩家继续游戏\r\n     */\r\n    function playerContinue(BBPlayer storage self, uint256 additionalBet) internal {\r\n        self.totalBet += additionalBet;\r\n        self.state = PlayerState.ACTIVE;\r\n        self.hasActedThisRound = true;\r\n    }\r\n\r\n    /**\r\n     * @dev 是否有效\r\n     */\r\n    function isValid(BBPlayer storage self) internal view returns (bool) {\r\n        return self.addr != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev 重置玩家数据\r\n     */\r\n    function playerReset(BBPlayer storage self) internal {\r\n        self.state = PlayerState.JOINED;\r\n        self.hasActedThisRound = false;\r\n        self.totalBet = 0;\r\n        self.isWinner = false;\r\n        self.cards = [0, 0, 0, 0, 0];\r\n        self.cardType = CardType.NONE;\r\n    }\r\n}\r\n"
    },
    "contracts/BBStructs.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./BBTypes.sol\";\r\nimport \"./BBPlayer.sol\";\r\n\r\n/**\r\n * @title BBStructs\r\n * @dev 牛牛游戏结构体定义\r\n */\r\n\r\nstruct GameConfig {\r\n    uint8 maxRoomCount;\r\n    uint8 maxPlayers;\r\n    uint8 maxJoinTablesCount;\r\n    uint8 maxBankerFeePercent;\r\n    uint256 playerTimeout;\r\n    uint256 tableInactiveTimeout;\r\n    uint8 liquidatorFeePercent;\r\n    address gameMainAddress;\r\n    address rewardPoolAddress;\r\n    address roomCardAddress;\r\n    address roomLevelAddress;\r\n    address gameTableFactoryAddress;\r\n}\r\n\r\n// 奖励池结构\r\nstruct RewardPoolInfo {\r\n    uint256 poolId;           // 奖励池ID\r\n    string name;              // 奖励池名称\r\n    address banker;           // 创建者（庄家）地址\r\n    uint256 totalAmount;      // 总奖池金额\r\n    uint256 rewardPerGame;    // 每局游戏奖励金额\r\n    uint256 winProbability;   // 中奖概率（以百分之一为单位）\r\n    uint256 remainingAmount;  // 剩余奖池金额\r\n    bool inUse;              // 是否正在使用\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\nstruct RoomCardNftType {\r\n    uint256 id;              // Unique identifier for the card type\r\n    string name;             // Name of the card type (e.g., \"SILVER\", \"GOLD\", \"DIAMOND\")\r\n    uint8 maxPlayers;        // Maximum number of players allowed\r\n    uint256 price;           // Price to purchase this card\r\n    string uriSuffix;        // URI suffix for metadata\r\n    bool active;             // Whether this card type is active\r\n    uint256 maxMint;         // Maximum mint amount for this card type\r\n    string rarity;           // Rarity of the card type\r\n    uint256 minted;          // 已mint数量\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\n// 定义卡片详细信息结构体\r\nstruct RoomCardNftDetail {\r\n    uint256 tokenId;       // 卡片的token ID\r\n    RoomCardNftType nftType;     // 继承CardType的所有属性\r\n}\r\n\r\n// Room level structure\r\nstruct RoomLevelNftType {\r\n    uint256 id;              // Unique identifier for the level type\r\n    string name;             // Name of the level (e.g., \"BRONZE\", \"SILVER\", \"GOLD\")\r\n    uint256 maxRooms;        // Maximum number of rooms allowed with this level\r\n    uint256 price;           // Price to purchase this level\r\n    string uriSuffix;        // URI suffix for metadata\r\n    bool active;             // Whether this level type is active\r\n    uint256 maxMint;         // Maximum mint amount for this level type\r\n    uint256 minted;          // Already minted amount for this level type\r\n    string rarity;           // Rarity of this level type\r\n\r\n    uint256[10] __gap;\r\n}\r\n\r\n// Level details structure for returning comprehensive information\r\nstruct RoomLevelNftDetail {\r\n    uint256 tokenId;         // Level token ID\r\n    RoomLevelNftType nftType;     // Level type information\r\n}\r\n\r\n// 添加一个新的结构体用于返回游戏桌信息\r\nstruct GameTableView {\r\n    bool active;\r\n    uint256 gameRound;\r\n    uint256 gameLiquidatedCount;\r\n    address tableAddr; // 游戏桌合约地址\r\n    uint256 tableId;\r\n    string tableName;\r\n    address bankerAddr;\r\n    uint256 betAmount;\r\n    uint8 bankerFeePercent;\r\n    uint256 totalPrizePool;\r\n    uint8 playerCount;\r\n    uint8 maxPlayers;\r\n    uint256 creationTimestamp;\r\n    uint256 liquidateDeadline;\r\n    GameState state;\r\n    uint8 liquidatorFeePercent;\r\n    uint8 playerContinuedCount;\r\n    uint8 playerReadyCount;\r\n    address[] playerAddresses;\r\n    uint256 currentRoundDeadline;\r\n    uint256 playerTimeout;\r\n    uint256 tableInactiveTimeout;\r\n    uint256 lastActivityTimestamp;\r\n    uint256 rewardPoolId;\r\n    RewardPoolInfo rewardPoolInfo; // 奖励池信息，如果没有奖励池，则返回空结构体\r\n    uint256 implementationVersion; // 添加实现版本号\r\n    uint8 firstBetX;\r\n    uint8 secondBetX;\r\n    uint256 bankerStakeAmount;\r\n    bool canNext;\r\n    string nextTitle;\r\n    string nextReason;\r\n    address rewardAddr;\r\n    uint256 rewardAmount;\r\n    string chatGroupId;\r\n}\r\n\r\n// 添加一个新的结构体用于返回游戏桌信息\r\nstruct GameTableInfoShort {\r\n    bool active;\r\n    uint256 gameRound;\r\n    uint256 gameLiquidatedCount;\r\n    address tableAddr; // 游戏桌合约地址\r\n    uint256 tableId;\r\n    string tableName;\r\n    address bankerAddr;\r\n    uint256 betAmount;\r\n    uint8 bankerFeePercent;\r\n    uint8 playerCount;\r\n    uint8 maxPlayers;\r\n    GameState state;\r\n    uint256 lastActivityTimestamp;\r\n    uint256 rewardPoolId;\r\n    RewardPoolInfo rewardPoolInfo; // 奖励池信息，如果没有奖励池，则返回空结构体\r\n}\r\n\r\nstruct UserInfo {\r\n    address[] tables;\r\n    address[] joinedTables;\r\n    mapping(address => uint256) joinedTableIndex;\r\n}"
    },
    "contracts/BBTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\n/**\r\n * @title BBTypes\r\n * @dev 牛牛游戏类型定义\r\n */\r\n\r\n// 游戏状态\r\nenum GameState {\r\n    NONE,\r\n    WAITING,\r\n    FIRST_BETTING,\r\n    SECOND_BETTING,\r\n    ENDED,\r\n    SETTLED,\r\n    LIQUIDATED\r\n}\r\n\r\n// 玩家状态\r\nenum PlayerState {\r\n    NONE,\r\n    JOINED,\r\n    READY,\r\n    ACTIVE,       // 当前参与游戏中，未弃牌\r\n    FOLDED        // 弃牌\r\n}\r\n\r\n// 牌型\r\nenum CardType {\r\n    NONE,\r\n    NO_BULL,\r\n    BULL_1,\r\n    BULL_2,\r\n    BULL_3,\r\n    BULL_4,\r\n    BULL_5,\r\n    BULL_6,\r\n    BULL_7,\r\n    BULL_8,\r\n    BULL_9,\r\n    BULL_BULL,\r\n    FIVE_BOMB,\r\n    FIVE_SMALL,\r\n    FIVE_FLOWERS\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "viaIR": true,
    "evmVersion": "london",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}